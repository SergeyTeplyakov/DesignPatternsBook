## Глава 2. Принцип единой обязанности

**ЦИТАТА:** _"Нельзя объять необъятное"_. Козьма Прутков

**Принцип единственной обязанности (Single-Responsibility Principle, SRP)**: _У класса должна быть только одна причина для изменения_.
Роберт Мартин. "Принципы, паттерны и практики гибкой разработки" [Martin2006]

В разработке ПО есть одна неизменная составляющая - это неизбежность внесения изменений. Как бы мы ни старались, как бы мы не пытались продумать все до мелочей, рано или поздно требования изменятся. Требования меняются из-за исходного недопонимания задачи, из-за изменений во внешнем мире, из-за более точного понимания своих собственных нужд заказчиком, или из-за десятков других причин. На самом деле, важны не столько причины возникновения изменений, сколько наша возможности по адаптации системы к новым требованиям и простота внесения изменений.

Одним из подходов к упрощению внесения изменений является создание чрезмерно гибких и расширяемых систем. Систем, логика которых может быть изменена без перекомпиляции, с помощью конфигурационных файлов, плагинов и других продвинутых техник. Но у этого подхода есть несколько недостатков. Мы (разработчики) очень плохо разбираемся в вопросах предсказания будущего и не знаем, в какую сторону будет дуть сильнее всего ветер перемен, и как именно система должна расширятся. А поскольку подобная гибкость приводит к увеличению сложности, то такой подход очень часто приводит к решениям вида "чемодан без ручки", который и выбросить не хочется, и сопровождать сложно.

Другой подход к обеспечению расширяемости пересекается с техниками борьбы со сложностью: программная сущность (класс, модуль, метод) должна решать по возможности лишь одну задачу, но делать это хорошо. Как это решает проблему изменений? Очень просто. Чем меньше у метода, класса  или модуля вспомогательных задач, тем ниже вероятность "случайных" или "вейерных" изменений.

Фредерик Брукс в своей книге "Мифический человеко-месяц" вводит понятия етественной сложности (essential complexity) и привнесенной или случайной сложности (accidental complexity). Естественная сложность является частью сложности предметной области, избавиться от которой мы не в состоянии. Привнесенная же сожность, является ненужной сложностью, которую внесли мы сами, путем неудачного дизайна, за счет излишне сложных библиотек или конструкций языка программирования. Изменения также можно разделить на "естественные", которые возникают из-за изменения бизнес-логики или требуемого поведения, и "случайные" - изменения, которых мы вынуждены вносить из-за неудачного дизайна. Изменения в законодательстве приведут к изменениям в классе вычисления заработной платы и являются "естественными". Но мы не хотим его менять при изменении пользовательского интерфейса, смене СУБД, или из-за изменений формата одного из отчетов приложения.

Существует ряд патологических случаев нарушения принципа единственной обязанности. Классы бизнес-логики, которые знают о пользовательском интерфейсе или о базе данных. Класс windows-сервиса c обилием бизнес-логики. Статические утилитные классы, изменяющие глобальное состояние. Есть примеры нарушения SRP на уровне приложений: Windows Forms приложение, которое хостит WCF сервис или windows-сервис, взаимодействующий с пользователем с помощью диалоговых окон. Эти примеры показывают, что нарушения SRP бывают как на микро уровне - уровне классов или методов, и на макро уровне - на уровне модулей, подсистем и целых приложений.

Приведенные выше примеры не столько нарушают SRP, сколько противоречат здравому смыслу. В реальном мире проблемы бывают более тонкими, когда один разработчик говорит, что дизайн хорош, а для другого он серьезно «попахивает» и вам хочется найти весомые аргументы против текущего решения. Чтобы понять, нарушает ли код принцип единой обязанности важно понимать, какую проблему он должен решать.

### Для чего нужен SRP?

**Принцип единой ответственности предназначен для борьбы со сложностью**. Когда в нашем приложении всего 200 строк, то дизайн как таковой вообще не нужен. Достаточно аккуратно написать 5-7 методов и решить задачу влоб. Проблемы возникают, когда система растет и увеличивается в масштабах. Поскольку сложность растет не линейно, важность хорошего дизайна резко возрастает при увеличении размера приложения. Приходится вспоминать такие страшные понятия, как "абстракции" и "сокрытия информации", лучше продумывать обязанности каждого класса, чтобы у разработчика сегодня и через год была возможность сосредоточиться на главной проблеме метода/класса/модуля и проигнорировать второстепенные детали.

Основным строительным блоком ОО-приложения является класс, поэтому обычно думают об обязанностях класса, но поскольку основную работу выполняют методы, то очень важно, чтобы они также были "цельными" (cohesive) и "сфокусированными" на решении одной задачи. Но не стоит подходить к принципу единой обязанности через чур буквально. В противном случае, любой класс или метод будет нарушать SRP. Метод валидирует аргументы и выполняет свою работу? Нарушение SRP! Метод записывает информацию в лог и делает что-то еще? Нарушение SRP! Метод устанавливает соединение с базой данных и выполняет запрос? Нарушение SRP!

Наличие или отсутствие нарушения SRP очень сильно зависит от того, насколько сложным является каждый из описанных выше аспектов. Метод и может нарушать SRP, если логика валидации аргументов сложна размазана по всему методу. Читать такой метод становится сложно, а понять, что же он делает - затруднительно:

```csharp
public void SaveToDatabase(string connectionString)
{
  if (string.IsNullOrEmpty(connectionString))
    throw new ArgumentNullException("connectionString");

  var connectionManager = ObtainConnectionManager();

  if (!connectionString.Contains("Server") && !connectionString.Contains("Database"))
    throw new ArgumentException("Server and Database should be specified", "connectionString");

  if (!connectionString.Contains("Password"))
    InsertPasswordFromAppConfig(ref connectionString);

  // Формирование и выполнение запроса
}
```

Простая логика валидации нужна любому открытому методу. Но как только сложность валидации возрастает, то ее нужно выность в отдельные методы.

Аналогично, слишком большое количество трассировочного кода говорит о неудачной реализации метода, и всем станет легче, если логирование будет вынесено с помощью декоратора (**TODO: в книге будет ссылка на главу**), или диагностические сообщения будут формироваться в отдельном методе (*). Тоже самое касается ипримера с установлением соединения с базой данных и выполнением запроса: если метод формирует строку подключения, создает его, выполняет запрос и разбирает результат, то он делает слишком многое! Но если основная работа по каждому из этих этапов выполняется отдельными методами, а высокоуровневый метод лишь вызывает три метода, то никаких претензий к нему не будет:

(*) Сноска: В .NET приложении можно воспользоваться встроенным в Windows инструментом логгирования - Event Tracing for Windows (ETW). ETW позволяет отделить получение диагностических сообщений от основного кода. Кроме того, ETW является наиболее эффективным способом логгирования и позволяет сохранять тысячи событий в секунду, с последующим удобным отображением.

```csharp
public void SaveToDatabase()
{
  using(var connection = CreateConnection())
  {
    using (var command = CreateInsertCommand(insertSql))
    {
      command.ExecuteNonQuery();
    }
  }
}
```

### Пример эволюции дизайна и сложности решения

При развитии приложения происходит постоянное изменение или уточнение требований, что приводит к увеличению сложности бизнес логики. Дизайн решения должен эволюционировать вместе с развитием системы и пониманием решаемых ею задач. После внесения любых существенных изменений, важно валидировать дизайн на предмет его чистоты и соответствия принципам проектирования и здравому смыслу. То, что на первых порах можно было поместить лишь в один метод, может вырасти в целую иерархию классов.

Недавно я занялся разработкой плагина для [JetBrains ReSharper](https://www.jetbrains.com/resharper/) (дополнения к Visual Studio), предназначенного для упрощения контрактного программирования и использования библиотки Code Contract. Основная цель плагина: упростить генерацию предусловий/постусловий/инвариантов для существующего кода, анализаторы для поиска типовых ошибок и отображения ошибок компилятора контрактов (Code Contract Compiler) прямов в IDE (Integrated Development Environment).

Первой возможностью этого плагина было добавление проверки предусловия аргумента. Путем нажатия `Ctrl + Enter` на аргументе `string str`, плагин должен генерировать `Contract.Requires(str != null);`. ReSharper поддерживает большое количество встроенных контекстных действий (Context Action), автор дополнения может добавлять свои собственные действия и определять, когда оно должно быть доступным в зависимости от состояния кода.

*ПРИМЕЧАНИЕ*
В Visual Studio 14 появится возможность, аналогичная контекстным действиям ReSharper - Universal Actions (**TODO: пока не уверен, так ли они называются!**)

Контекстные действия в ReSharper API представлены базовым классом `ContextActionBase`:

```csharp
public abstract class ContextActionBase
{
    public abstract void Execute();
    public abstract bool IsAvailable();
    public abstract string Text { get; }
}
```

(Настоящая версия класса `ContextActionBase` в R# API несколько сложнее, но суть именно такая.)

Для начала я хотел добавить контекстное действие для добавления проверки аргументов на `null`, и выделил класс `AddRequiresContextAction`. Поскольку на начальных этапах в голову приходят лишь небольшое число граничных случаев, то класс `AddRequiresContextAction` содержал всю логику: он сам определял доступность добавления предусловия (аргумент метода ссылочного типа и еще не проверен на `null`), а также логику по добавлению предусловия непосредственно в метод.

Нарушал ли данный класс SRP? Сложно сказать. И да, и нет. С одной стороны, сам интерфейс базового класса говорит о необходимости выполнения нескольких действий, с другой стороны у класса на тот момент было всего три метода, каждый из которых отвечал за определенный аспект поведения, а их реализация была довольно простой. Можно сказать, что данный класс был «крепко связанный» (highly cohesive), а значит нарушать SRP не мог.

Но по мере того, как росло мое понимание предметной области добавлялось все больше и больше граничных условий. Со временем я понял, что действие должно быть недоступным в следующих условиях:
* Метод проверяет аргумент на `null` с помощью `Contract.Requires`
* Метод проверяет аргумент на `null` с помощью if-throw-ArgumentException
* Метод содержит аргумент по-умолчанию и значение по-умолчанию равно `null`

Потом появилась дополнительная логика для работы с интерфейсами и абстрактными классами. Класс `AddRequiresContextAction` начал усложняться и граф вызовов его внутренних методов стал выглядеть так:

![Requires Internals](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch01_Image1.jpg "Requires Internals")

Даже по рисунку видно, что у класса появилось две ярко выраженные ответственности: проверка допустимости действия и его исполнение, которые не были столь очевидны до этого. В результате, я выделил два дополнительных класса: `AddRequiesAvailability` и `AddRequiresExecutor`, которые стали отвечать за «доступность» действия и за его «выполнение». Со временем даже эти два класса были разбиты на более мелкие составляющие, поскольку потребовалось учитывать еще и особенности свойств языка C#, и один простой класс "вырос" в граф взаимодействующих объектов (*):

(*) Сноска: Текущую версию класса `AddRequiresContextAction` можно посмотреть в исходном коде [Code Contract Editor Extension на github](https://github.com/SergeyTeplyakov/ReSharperContractExtensions/blob/7d840c0cc23574a037362817bee5ccdefdec3863/ContractExtensions/ContextActions/Requires/AddRequiresContextAction.cs)).

Понятие "обязанности" изменяется и уточняется со временем. То, что вначале казалось единой обязанностью, может усложниться настолько, что для нее понадобится несколько классов. Нельзя абстрактно говорить о нарушении классом обязанности, пока не получено более точных сведений о том, что эта обязанность из себя представляет.

Изменения в дизайне не должны диктоваться необходимостью следованию принципам проектирования, но он могут служить дополнительным стимулом к изменениям. Нарушение SRP означает слишком высокую сложность решения - классы разрастаются настолько, что перестают помещаться в голове. Затрудняется навигация, на глаза попадаются ненужные детали, связанные с второстепенными аспектами. Количество одновременных понятий, которые нужно держать в голове начинает превышать священные 7 ± 2 (*) и мы начинаем терять контроль над кодом.

Я хочу иметь возможность сосредоточиться на сложных аспектах системы по отдельности, и когда становится сложно это делать, я начинаю разбивать текущий класс на более мелкие составляющие.

(*) СНОСКА. Правило "семь плюс-минус-два" определяет объем кратковременной памяти человека. Эта закономерность была изучена американским психологом Джорджем Миллером и упоминается во многих книгах по проектированию ПО, например, в книге Грэди Буча "Объектно-ориентированный анализ и проектирование с примерами приложений". Это же магическое число лежит в основе борьбы со сложностью в разработке ПО и определяет разумное число полей класса, влияет на размер метода и число его аргументов. Если при чтении класса вам нужно думать о большем числе вещей, то понятность кода резко уменьшится.

### Применение SRP в реальной жизни

Принципы проектирования играют важную коммуникативную роль. Достаточно сказать, что "класс нарушает SRP", вместо более абстрактного объяснения слишком высокой сложности или слабой связности (low cohesion). Но для нормального исполнения коммуникативной функции, все должны понимать, что принцип означает.

Определение принципа единой ответственности достаточно запутанное, а классическое объяснение "дядюшки Боба" может лишь дополнительно сбивать с толку (Martin[2006] (*)):

(*) СНОСКА. Речь идет о книге Роберта Мартина "Принципы, паттерны и методики гибкой разработки", Символ-Плюс, 2011.

"В контексте принципа SRP мы будем называть обязанностью причину изменения. Если вы можете найти несколько причин для изменения класса, то у такого класса более одной обязанности.
…
Следует ли разделить эти обязанности? Все зависит от того, как именно изменяется приложение.
С другой стороны, если приложение не модифицируют таким образом, что эти обязанности изменяются порознь, то и разделять их нет необходимости. Более того, разделение в этом случае попахивало бы ненужной сложностью.
Отсюда вытекает следствие. Ось изменения становится таковой, только если изменение имеет место. Неразумно применять SRP – как и любой другой принцип, – если для того нет причин."

При объяснении принципов проектирования, и других аспектов разработки ПО, очень часто применяются метафоры: технический долг, выращивание системы и другие. Но "ось изменений" мне не кажется самой удачной метафорой для объяснения SRP. На практике я часто говорю о том, что класс нарушает SRP, но при этом я никогда не апеллирую к «осям изменений». Я говорю о тяжеловесности интерфейса и реализации, о решении классом не связанных друг с другом задач. О том, что здесь много кода и мало классов. Что в коде много лишнего шума, который мешает увидеть его основную суть. О том что высокоуровневая логика перемешана с низкоуровневыми деталями и т.п.

Готовить классы к будущим изменениям можно по разному. Можно начать с простого класса, который затем станет фасадом (**TODO: ссылка на главу с описанием Фасада**) для целого графа объектов, а можно сразу же выделить стратегию расчета, даже если она вам никогда не понадобится. Наличие осей изменений не должны приводить к преждевременному обобщению (premature generialization), проблеме очень похожей на преждевременную оптимизацию.

После того, как вы определили, что класс нарушает SRP очень важны ваши дальнейшие шаги. Если класс простой, то нарушение ничего не значит. Если класс сложный и делает слишком многое, значит нужно его разбивать на более мелкие составляющие. SRP помогает в поиске невыявленных ранее абстракций, достаточно сложных, чтобы им отвели отдельную именованную сущность и спрятали в их недрах все детали.  Разделение классов на составляющие диктуются не «осями изменений», а здравым смыслом и попыткой справиться с нарастающей сложностью системы.

### Типичные примеры нарушения SRP

* *Смешивание логики с инфраструктурой*. Бизнес-логика смешана с представлением, слоем персистентности, находится внутри WCF или windows-сервисов. Дожна быть возможность сосредоточиться на бизнес-правилах, не обращая внимания на второстепенные инфраструктурные детали.
* *Слабая связность (low cohesion)*. Класс/модуль/метод не является цельным и решает несколько несвязанных задач. Проявляется несколько групп методов, каждая из которых обращается к подмножеству полей, которые не используются другими методами.
* *Выполнение нескольких несвязанных задач*. Класс/модуль может быть цельным, но решать несколько несвязанных задач (вычисление заработной платы и построение отчета). Класс/модуль/метод должен быть "сфокусированными" на решении минимального числа задач.
* *Решение задач с разных уровней абстракции*. Класс/метод не должен решать задачи с разных уровней абстракции, даже если они относятся к одной задаче.

### Заключение
Следование принципам проектирования является не статической, а динамической характеристикой дизайна. Наибольшая опасность заключается в "загнивании" дизайна, когда внесение нескольких изменений приводит к разрастанию обязанностей и увеличению сложности. То, что вчера казалось лишь одной обязанностью, сегодня может потребовать целой иерархии классов. Каждый раз при изменении логики нужно анализировать дизайн на соответствие здравому смыслу и принципам проектирования.

Важность принципа единой ответственности резко возрастает при увеличении сложности. Если решение перестает помещаться в голове, то пришло время разбить его на более простые составляющие, каждая из которых будет решать лишь одну задачу.
