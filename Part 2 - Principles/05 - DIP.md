## Глава 6 - Принцип инверсии зависимостей

**Цитата**: _Когда душа уходит в пятки, встань вверх ногами и встряхнись!_

**Принцип инверсии зависимости (Dependency Inversion Principle – DIP)**:

* Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.
* Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Роберт Мартин. "Принципы, паттерны и практики гибкой разработки" [Martin2006]

Принцип инверсии зависимостей – один из самых известных сегодня принципов проектирования, который лежит в основе популярных техник внедрения зависимостей (Dependency Injection). Однако, если посмотреть лишь на его название и описание, то будет довольно сложно понять, что же он означает. А если спросить простых обывателей о том, как они понимают принцип инверсии зависимостей, то они начнут что-то говорить о пользе интерфейсов и абстракций, и, вообще, будут путаться в показаниях.

### Интерфейсы

В основе принципа инверсии зависимостей лежит использование интерфейсов (*). Одна группа классов реализует некоторый набор интерфейсов, а другая группа классов, принимает эти интерфейсы в качестве аргументов конструктора:

(*) Сноска: под интерфейсами в данном случае понимаются программные конструкции, объявленные с помощью ключевого слова `interface`. В большинстве случаев, вместо интерфейсов возможно использование абстрактных классов, и все рассуждения данной главы еще будут актуальными.

```csharp
interface ILogger
{
  void Info(string message);
}

class A
{
  public A(ILogger logger)
  {}
}

class Log4NetLogger : ILogger {...}
```
TODO: пример для затравки. Еще подумаю над ним!

Таким образом получается "слабосвязанный" дизайн, поскольку класс `А` знает лишь об интерфейсе `ILogger`, и не знает о конкретной реализации этого интерфейса. А следование Принципу замещения Лисков позволит заменить одну реализацию на другую, и получить гибкое решение, соответствующее принципу Открыт/Закрыт.

И хотя данные рассуждения вполне логичны, не стоит забывать, что у такого решения есть и обратная сторона. Наличие интерфейсов образует "дополнительный уровень косвенности" (который часто называют "дополнительным уровнем абстракции"), что затрудняет понимание системы. Полиморфизм - это GOTO объектного мира, который затрудняет понимание кода путем его чтения, поскольку вызываемый метод определяется во время исполнения.

За гибкость приходится платить увеличением сложности. Теперь клиентам класса `A` приходится решать проблему с поиском подходящей зависимости, даже если им это не интересно. Только представьте себе, что у класса `List<T>` появилась бы зависимость вида `IListGrowingPolicy`, которая бы отвечала за способ "роста" списка, а у класса `String` появилась бы зависимость `IInterningPolicy`, которая бы отвечала за политику интернирования.

Не для всех классов нужно выделять интерфейсы, и не все зависимости следует требовать извне в виде интерфейсов. Принцип инверсии зависимостей достаточно четко дает понять, когда нужно зависимость инвертировать, а когда можно создавать зависимости непосредственно в месте их использования.

### Слои
> У лука есть слои, у торта есть слои, и у Людоеда есть слои.
Шрек

Любое современное приложение разбито на слои, каждый из которых отвечает за определенный аспект поведения. На нижних уровнях находятся повторно используемые компоненты и инфраструктурный код, а слои более высокого уровня отвечают за логику приложения и пользовательский интерфейс (Larman2006):

![Image1](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch05_Image1.png)
Рисунок 6.1 - Многоуровневая архитектура современного приложения

Каждый слой отвечает за определенную область и использует сервисы нижележащих уровней для решения своих задач. Принцип единой обязанности говорит, что каждый класс, модуль или слой должен решать лишь одну задачу. Это значит, что инфраструктурный код доступа к данным не должен содержать бизнес-логики, а бизнес-логика не должна знать о пользовательском интерфейсе.

Слои нижнего уровня не знают и не должны знать о слоях верхнего уровня. Это позволяет использовать низкоуровневые слои повторно, упрощает понимание и развитие каждого из них, а также ограничивает распространение изменений.

Чем выше слой, тем специфичнее он для каждого конкретного приложения. На нижних уровнях находится инфраструктурный код, сервисы и ключевая бизнес-логика (core business logic). На верхних уровнях находится высокоуровневая бизнес-логика, которая отличает одно приложение от другого, а также пользовательский интерфейс. Такое разделение позволяет использовать код нижних уровней повторно, а также переходить с одного пользовательского интерфейса на другой, в случае необходимости.

Иерархичность и "слоеность" присуща как программной системе в целом, так и отдельным крупным модулям. По мере роста сложности предметной области или за счет появления дополнительных деталей, компоненты начинают дробиться на более мелкие составляющие, в основе которых будут лежать уже примитивные типы платформы и языка программирования.

> Сложные системы часто являются иерархическими и состоят из взаимозависимых подсистем, которые в свою очередь также могут быть разделены на подсистемы, и т.д., вплоть до самого низкого уровням.
Гради Буч "Объектно-ориентированный анализ и проектирование с примерами приложений"

Классы более высокого уровня обычно контролируют процесс создания и передачу управления классам нижних уровней. Класс `Logger` создает набор экземпляров `LogAppender` и передает им сформированное сообщение для сохранения. В некоторых случаях класс верхнего уровня не знает, какой точно класс нижнего уровня использовать. В этом случае очень помогает связка двух паттернов: Фабричный Метод + Стратегия (*).

(*) Будет ссылка на паттерна Фабричный Метод и Стратегия.

![Logger](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch05_Image2.png)
Рисунок 6.2 - Высокоуровневый дизайн логгера

Однако мы не всегда можем обеспечить передачу управления лишь сверху вниз по слоям приложения. Классы бизнес логики могут потребовать что-то от слоя пользовательского интерфейса. Инфраструктурному коду может потребоваться информация, недоступная на его уровне абстракции. Иногда классы вынуждены "зависеть" от чего-то, что находится вне поля их зрения.

### Наблюдатели

Классическим решением задачи связи нижних слоев с верхними является паттерн Наблюдатель (*). Самый простой способ отвязать класс от внешних зависимостей - добавить в него событие (event), с помощью которого он будет уведомлять всех заинтересованных подписчиков об изменении состояния. При этом логически, управление будет передано с нижнего уровня на верхний, однако знать о том, "что" будет происходить при вызове этого делегата, текущий класс не будет.

(*) СНОСКА: дать ссылку на главу с Наблюдателем.

Хорошим примером использования наблюдателей для передачи управления снизу вверх по слоям приложения является паттерн MVC (Model-View-Controller, Модель-Представление-Контроллер). Каждый класс в этом паттерне отвечает за отдельный аспект: Модель определяет бизнес правила, Вид отвечает за пользовательский интерфейс, а Контроллер обрабатывает входные события от пользователя и отвечает за логику приложения.

![Image 6-3](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch05_Image3.png)
Рисунок 6.3 - Паттерн Модель-Представление-Контроллер (*)

(*) СНОСКА: Распределение модели, контроллера и представления по слоям приложения может быть неоднозначным. Что считать верхним слоем, а что нижним? Согласно общепринятой классификации, описанной Крэгом Ларманом, конечная точка, с которой взаимодействует пользователь является наиболее высокоуровневой. За ней следом идет логика приложения, которая связывает слой пользовательского с доменными объектами. Именно этим объясняется порядок слоев на данном рисунке.

Классы моделей могут требовать что-то от вышестоящих слоев. Но поскольку слои нижнего уровня не должны знать напрямую о классах верхнего уровня, то данное "общение" осуществляется с помощью наблюдателей. Так, Модель не знает ничего о Контроллере и Представлении и общается с ними опосредованно с помощью событий. Паттерн MVC несколько нарушает данное правило и Контроллер обычно знает о пользовательском интерфейсе больше, чем нам бы того хотелось. Контроллер также обрабатывает входные данные от пользовательского интерфейса, что делает этот паттерн широко используемым в веб-приложениях, но практически не применимым в других видах приложений, например, WPF или Windows Forms.

Чтобы справиться с этими особенностями, возник другой паттерн, под названием - MVP (Model-View-Presenter, Модель-Представление-Презентер).

![Image 6-4](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch05_Image4.png)
Рисунок 6.4 - Паттерн Модель-Представление-Презентер

Главное отличие между паттернами MVP и MVC в том, что Презентер не обрабатывает входные данные пользователя, а также то, как он взаимодействует с Представлением. Презентер знает лишь об абстрактном представлении (`IView`), интерфейс которого объявляется на его уровне (например, в той же сборке), а реализуется - уровнем представления.

Помимо двух вышеперечисленных паттернов, существует еще один паттерн из семейства MVx - MVVM (Model-View-View Model, Модель-Представление-Модель представления). MVVM похож на MVP, однако вместо интерфейсов `IView` Модель представления "общается" с верхним уровнем с помощью событий, спрятанных в инфраструктурном коде за технологией привязки данных (Data Binding).

### Для чего нужен принцип инверсии зависимостей
**Принцип инверсии зависимостей предназначен для устранения прямых связей между классами или модулями с их высокоуровневыми зависимостями.**

![Image 6-5](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch05_Image5.png)
Рисунок 6.5 - Принцип инверсии зависимостей

Название принципа отражает нетипичность направления зависимостей: классы нижнего уровня определяют некоторый "контракт", которому должны следовать классы верхнего уровня. Классы верхнего уровня вынуждены выступать в роли "адаптеров" и подстраиваться под протокол, определенный на уровне ниже. При этом вместо "слаботипизированных" наблюдателей, текущий класс выделяет именованную зависимость в виде интерфейса, и требует ее в своем конструкторе от вышестоящего кода.

```csharp
// Reporter.dll - Нижний уровень
public interface IReportFormatter
{
  string FormatReport(Report report);
}

public class Reporter
{
  private readonly IReportFormatter _formatter;

  public Reporter(IReportFormatter formatter)
  {
    _formatter = formatter;
  }

  public void SendReport(Report report)
  {
    var formattedReport = _formatter.FormatReport(report);
    SendFormattedReport(formattedReport);
  }

  private void SendFormattedReport(string formattedReport)
  {}
}

// Application.dll - Верхний уровень
class XlsFormatter : IReportFormatter
{
  public string FormatReport(Report report)
  {
    // Форматируем отчет для отображения его в Excel
  }
}

class Application
{
  public void Run()
  {
    var reporter = new Reporter(new XlsFormatter());
    reporter.SendReport(GenerateReport());
  }
}

```

Класс `Reporter` определяет свои зависимости в виде интерфейса `IReportFormatter`, а класс `Application` адаптируется под его требования. Поэтому интерфейс `IReportFormatter` определяется на том же уровне, что и `Reporter`, а реализация этого интерфейса находится на более высоком уровне - уровне приложения. В результате прямые зависимости направлены сверху вниз - от приложения к модулю отчетов, а косвенные зависимости направлены в обратном направлении, что позволяет классу `Reporter` взаимодействовать во время исполнения с `XlsFormatter` полиморфным образом.

### Остерегайтесь неправильного понимания DIP
Чрезмерное или необдуманное использование любого принципа проектирования может привести к переусложнению дизайну и принцип инверсии зависимостей здесь не  исключение. Распространение библиотек управления зависимостями - IoC-контейнеров, (*) может привести к выделению чрезмерного количества интерфейсов, что делает решение настолько "слабосвязным", что разобраться в нем становиться практически невозможно.

(*) СНОСКА: IoC-контейнеры (Inversion of Control Containers) представляют собой библиотеки для автоматического управления зависимостями. Их главным действующим лицом является контейнер, который может создавать экземпляры любого типа в приложении. Для этого контейнер конфигурируется в точке входа (Entry Point) приложения путем задания ассоциации между интерфейсами и их реализацией. Теперь, если пользователь "попросит" у контейнера экземпляр некоторого типа, то контейнер самостоятельно "найдет" все его зависимости и передаст их требуемому классу через аргументы конструктора, или установит соответствующие свойства. Подробнее о них можно почитать в книге Марка Сиимана "Dependency Injection in .NET".

Причина неправильного использования принципа инверсии зависимостей кроется в недопонимании его целей, а также в описании этого принципа его автором - Робертом Мартин. Вот что он пишет в своей книге [Martin2006]:

> DIP выражается простым эвристическим правилом: «Зависеть надо от абстракций». Оно гласит, что не должно быть зависимостей от конкретных классов; все связи в программе должны вести на абстрактный класс или интерфейс.

> * Не должно быть переменных, в которых хранятся ссылки на конкретные классы.
> * Не должно быть классов, производных от конкретных классов.
> * Не должно быть методов, переопределяющих метод, реализованный в одном из базовых классов.

И далее:
> Конечно, эта эвристика хотя бы раз да нарушается в любой программе. … В большинстве систем класс, описывающий строку, конкретный. Такой класс изменяется редко, поэтому в прямой зависимости от него нет никакой беды. Однако конкретные классы, являющиеся частью прикладной программы, которые пишем мы сами, в большинстве случаев изменчивы. Именно от таких конкретных классов мы и не хотим зависеть напрямую. Их изменчивость можно изолировать, скрыв их за абстрактным интерфейсом.

Буквальное следование принципу DIP по такому описанию чревато серьезными последствиями для дизайна. В последнее время легко столкнуться с проблемой чрезмерно "абстрактных" решений, когда интерфейсов слишком много, и решение настолько "гибкое" и "слабосвязное", что просто невозможно понять, кто за что отвечает и откуда начать изучение системы.

#### Тестируемость решения vs. Подрыв инкапсуляции
Сегодня выделение интерфейсов часто объясняют необходимостью юнит-тестирования. Дескать, если класс создает свои зависимости самостоятельно, то как же мы сможем протестировать его в изоляции? Если же класс принимает все свои зависимости извне, да еще и в виде интерфейсов, то мы сможем "замокать" (*) все, что угодно и добиться 100% покрытия тестами!

(*) Существует несколько видов объектов-подделок, используемых в юнит-тестах, которые объединяются общим названием "test doubles". Моки (mocks) и стабы (stubs) являются двумя наиболее распространенными видами подделок, которые предназначены для проверки поведения и эмуляции состояния. Далеко не все изоляционные фреймворки разделяют эти два понятия, поэтому многие из них (такие, как Moq), любые подделки называют моками (mocks), что сделало этот термин применимым для описания любых подделок.
Подробнее о разнице между стабами и моками можно прочитать в моей статье "Programming Stuff: Стабы и Моки" (bit.ly/StubsVsMocks)

Проблема такого подхода в том, что он легко может подорвать инкапсуляцию текущего класса! Если зависимость находится на более низком уровне абстракции, то вызывающему коду она будет не интересна. Пользовательскому интерфейсу не важно, как именно реализована модель, и какая именно инфраструктура используется двумя слоями ниже. А слою бизнес-логики вряд ли интересны подробности реализации инфраструктурного слоя для удаленного взаимодействия с клиентами. С "колокольни" высокого уровня бывает просто невозможно решить, что же нужно передать в качестве `IPartitioningStrategy` нашей модели, и почему вообще меня это должно интересовать?

Исходный смысл принципа инверсии зависимостей в том, чтобы классы нижнего уровня взаимодействовали с верхним уровнем косвенно, ничего не зная о нем конкретного. Но он совершенно не означает, что теперь классы верхнего уровня должны знать о всех внутренних проблемах нижележащих слоев.

Существует несколько причин, почему класс может требовать зависимость в виде аргумента конструктора или метода:
* Поскольку реализация зависимости находится на более высоком уровне (следование принципу DIP).
* Существует множество реализаций зависимости и класс на этом уровне не может решать, какой из них выбрать (следование принципу Открыт-Закрыт).
* Поведение зависимости может быть завязано на внешнее окружение - файлы, базы данных, сокеты.

В первых двух случаях класс самостоятельно не может решить, какой конкретный тип зависимости использовать, поэтому просит "верхний" уровень помочь ему в этом. Последний случай более специфичен. Иногда мы можем осознанно пожертвовать инкапсуляцией в угоду тестируемости, особенно при наличии сложной логики в текущем классе и невозможности разделить его на более простые составляющие для тестировании их в изоляции.

Предположим, мы пишем класс чтения конфигурации, который читает ее из файла. Использование классов `File` или `FileStream` напрямую не позволит протестировать наше решение без внешнего окружения. В этом случае мы можем модифицировать наш класс, чтобы вместо имени файла передавать поток ввода-вывода (экземпляр `Stream`):

```cshap
public class ConfigurationReader : IDisposable
{
  private readonly Stream _stream;
  private readonly bool _disposeRequired;

  public ConfigurationReader(Stream stream, bool disposeRequired)
  {
    _stream = stream;
    _disposeRequired = disposeRequired;
  }

  public Configuration Read()
  {
    // Используем _stream для чтения конфигурации
  }

  public void Dispose()
  {
    if (_disposeRequired)
    {
      _stream.Dispose();
    }
  }
}
```

Теперь мы сможем в тестах использовать `MemoryStream` с требуемым содержимым, чтобы проверить основные граничные условия реализации. Данное решение часто используется на практике, но у него есть несколько особенностей. Во-первых, можно подумать о том, чтобы скрыть "тестируемость" от клиентов. Можно сделать конструктор, принимающий `Stream` внутренним, и добавить открытый конструктор или фабричный метод, принимающий имя файла:

```csharp
  internal ConfigurationReader(Stream stream, bool disposeRequired)
  {}

  pulbic static ConfigurationReader Create(string fileName)
  {
    var fileStream = new FileStream(path, FileMode.Open);
	  return new ConfigurationReader(fileStream, true);
  }
```

Во-вторых, нужно обязательно протестировать реализацию `ConfigurationReader`, работающую с файлом в интеграционных тестах (*). В юнит-тестах мы можем хорошо проверить логику, но вряд ли сможем хорошо протестировать граничные условия, возможные при работе с настоящими файлами: проверить вопросы безопасности, отсутствия файла и другие ошибки, возможные лишь при работе с настоящими файлами. Обилие интерфейсов и 100% покрытие кода юнит-тестами не гарантирует отсутствие ошибок в реальном окружении.

(*) ВРЕЗКА: *Юнит-тесты vs. Интеграционные тесты*
Существуют разные точки зрения на то, что считать юнит-тестом (модульным тестом), а что считать интеграционным тестом. Хорошее определение юнит-теста можно найти в статье Мартина Фаулера: http://martinfowler.com/bliki/UnitTest.html. Главное отличие интеграционного теста в том, что он проверяет поведение тестируемого кода с реальным окружением - файлами, реальными сетевыми соединениями или базами данных. Данная особенность приводит к двум важным отличиям юнит-тестов от интеграционных тестов: 1) интеграционные тесты работают существенно дольше и 2) поломка интеграционного теста не означают ошибку в коде приолжения, а может гововрить о проблемах в тестовом окружении. Поэтому разумно выделять интеграционные тесты в отдельную сборку, что позволит запускать их отдельно от юнит-тестов.

Использование напрямую классов, работающих с файлами, сокетами, базой данных и т.п. в бизнес-коде приложения может быть проблематичным. Инфраструктурные классы являются низкоуровневыми и должны использоваться в инфраструктурном слое или низкоуровневых сервисах. Нет смысла выделять интерфейс `IFileStream` и передавать его через конструктор десятку классов. Интерфейс работы с файлами является низкоуровневым и не должен использоваться в слоях бизнес-логики или логики приложения. Чтение из файла может быть частью реализации высокоуровневого кода, но тогда, вместо выделения интерфейса работы с файлами, лучше выделить некоторую высокоуровневую абстракцию, например, `IConfigurationReader` или `ICustomDataProvider`, одна из реализаций которых будет получать нужные данные из файла.

### Управление зависимостями
> Приложите все усилия, чтобы вы управляли зависимостями в коде, а не они управляли вами.    
Programming Stuff: "Управление зависимостями" (bit.ly/DependencyManagementArticle)

Принцип инверсии зависимостей лежит в основе более общей задачи, с которой сталкивается разработчик - задачей управления зависимостями классов и модулей. Существует несколько критериев, которые нам следует держать в голове при проектировании новых классов и модификации существующих.

**Минимизация зависимостей**

Класс должен зависеть от минимального числа внешних классов. Если классу нужен провайдер работы с базой данных, конфигуратор, прокси к удаленному серверу и форматтер отчетов, то это явно говорит о том, что класс делает слишком многое. Если нарисовать в голове или на бумаге диаграмму объектов, то экземпляр рассматриваемого класса не должен выглядеть пауком, сидящем в центре паутины. Важно различать внешние зависимости, передаваемые извне через аргументы конструктора, от конкретных классов, экземпляры которых создаются напрямую и являются деталями реализации класса.

**Сделать ключевые зависимости класса явными**

Основная проблема использования паттерна Синглтон (*) в том, что читая "заголовок" некоторого класса число его зависимостей не очевидно. Даже если вы вынуждены использовать синглтон, то сделайте его использование явным: инициализируйте поле в конструкторе, но не используйте сам синглтон непосредственно в телах методов:

(*) Сноска: дать ссылку на паттерн Синглтон.

```csharp
class SingletonClient
{
  private readonly Singleton _singleton;
  public SingletonClient()
  {
    _singleton = Singleton.Instance;
  }

  public void Foo()
  {
    // Используем поле _singleton, а не Singleton.Instacen
  }
}
```

Внешние зависимости класса по своему определению должны контролироваться вызывающим кодом, поэтому их использование должно быть максимально очевидным для читателя. Поэтому если классу требуется подключение к базе данных для своей работы, то лучше принимать ее через аргументы конструктора, а не протягивать эту зависимость через глобальные объекты. Когда ключевых зависимостей станет слишком много (больше 4-х), то это сразу же станет сигналом к тому, что часть из них не главные, они слишком низкоуровневые и должны быть объединены в более высокоуровневые сущности, или же наш класс стал слишком сложным.

**Сделать класс тестируемым**

Обычно, невозможность протестировать некоторую функциональность класса говорит о проблемах в его дизайне. Если вы не можете протестировать процесс разбора данных, поскольку они читаются из файла, то, возможно, стоит выделить обязанность разбора данных в отдельный класс. 

Альтернативный способ заключается в выделении поведения, завязанного на внешнее окружение в отдельный класс и отвязаться от реализаии с помощью выделения интерфейса.

Но важно понимать, что дробление классов на слишком больше количество может усложнить понимание кода. А также то, что мы не можем абстрагироваться от внешнего окружения до бесконечности. Если мы реализуем класс `FileStream`, то мы не можем выделить дополнительный интерфейс для обеспечения тестируемости. В этом случае нам придется использовать интеграционные тесты, или такие инструменты, как Shims из Microsoft Fakes, которые позволяют перехватить и "замокать" любые методы, а не только виртуальные (*).

(*) Сноска: Шимы предоставляют возможность подменить поведение любого метода, включая статические и/или закрытые методы библиотеки BCL. Использование этого инструмента для юнит-тестирования должно быть последним вариантом, когда ни один другой способ обеспечения тестируемости класса не подходит. TODO: возможно стоит рассказать об этом подробнее.

### Примеры нарушения принципа инверсии зависимостей
* Низкоуровневые классы напрямую общаются с высокоуровневыми классами: модели знают о пользовательском интерфейсе или инфраструктурный код знает о бизнес-логике.
* Низкоуровневые классы используют множество наблюдателей для взаимодействия с верхним уровнем. Использование делегатов подходит для простой связи класса с внешним окружением, но если их становится много, то значительно лучше объединить их в интерфейс, с понятным названием и предполагаемым поведением.
* Классы принимают низкоуровневые интерфейсы (модель принимает `IFileStream`), что подрывает инкапсуляцию системы и делает ее слишком "плоской".

### Заключение
"Простое эвристическое правило - зависеть нужно от абстракций", на деле оказалось более сложным, чем могло показаться изначально.

Принцип инверсии зависимостей не сводится лишь к выделению интерфейсов и передаче их через конструктор. DIP объясняет для чего нужно это делать. Классы имеют право контролировать свои детали реализации, но некоторые аспекты находятся за пределами их компетенции. Чтобы не завязываться на классы верхнего уровня, класс может объявить некоторый интерфейс, и потребовать его реализацию через аргументы конструктора. Таким образом мы можем "инвертировать" зависимости и позволить классам нижних уровней взаимодействовать с другими частями системы, ничего конкретного о них не зная.
