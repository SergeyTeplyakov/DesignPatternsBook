## Глава 6 - Принцип инверсии зависимостей

**Цитата**: _Когда душа уходит в пятки, встань вверх ногами и встряхнись!_

**Принцип инверсии зависимости (Dependency Inversion Principle – DIP)**:

* Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.
* Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Роберт Мартин. "Принципы, паттерны и практики гибкой разработки" [Martin2006]

Принцип инверсии зависимостей – один из самых известных сегодня принципов проектирования, который лежит в основе популярных техник внедрения зависимостей (Dependency Injection). Однако, если посмотреть лишь на его название и описание, то будет довольно сложно понять, что же он означает. А если спросить простых обывателей о том, как они понимают принцип инверсии зависимостей, то они начнут что-то говорить о пользе интерфейсов и абстракций, и, вообще, будут путаться в показаниях.

### Слои
> У лука есть слои, у торта есть слои, и у Людоеда есть слои.
Шрек

Любое современное приложение разбито на слои, каждый из которых отвечает за определенный аспект поведения. На нижних уровнях находятся повторноиспользуемые компоненты и инфраструктурный код, а более высокие слои отвечают за логику приложения и пользовательский интерфейс (Larman2006):

![Image1](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch05_Image1.png)
Рисунок 6.1 - Многоуровневая архитектура современного приложения

Каждый слой отвечает за определенный область и использует сервисы нижележащих уровней для решения своих задач. Слои нижнего уровня не знают и не должны знать о слоях верхнего уровня. Это позволяет использовать низкоуровневые слои повторно, упрощает понимание и развитие каждого из них, а также ограничивает влияние распространение изменений. Принцип единой обязанности говорит, что каждый класс, модуль или слой должен решать лишь одну задачу. Это значит, что инфраструктурный код доступа к данным не должен содержать бизнес-логики, а бизнес-логика не должна знать о пользовательском интерфейсе.

Чем выше слой, тем специфичнее он для каждого конкретного приложения. За счет повторного использования слоев нижних уровней мы получаем некоторую пирамиду, в основании которой лежат проверенные компоненты, на основе которых выстраивается логика приложения. Иерархичность и "слоеность" присуща как программной системе в целом, так и отдельному крупному модулю. По мере роста сложности предметной области или за счет появления дополнительных деталей, компоненты начинают дробиться на более мелкие составляющие, в основе которых будут лежать уже примитивные типы платформы и языка программирования.

> Сложные системы часто являются иерархическими и состоят из взаимозависимых подсистем, которые в свою очередь также могут быть разделены на подсистемы, и т.д., вплоть до самого низкого уровням.
Гради Буч "Объектно-ориентированный анализ и проектирование с примерами приложений"

Классы более высокого уровня обычно контролируют процесс создания и передачу управления классам нижних уровней. Класс `Logger` управляет процессом создания `LogAppender` и передает сформированное ему сообщение для сохранения. Класс `Repository` создает подключение к базе данных и требуемую команду, а затем исполняет ее. (TODO: нужны еще примеры!). В некоторых случаях класс верхнего уровня не знает, какой точно класс нижнего уровня использовать. В этом случае очень помогает связка двух паттернов: Фабричный Метод + Стратегия (*).

(*) Будет ссылка на паттерна Фабричный Метод и Стратегия.

Например, логгер может содержать множество классов сохранения данных, скрытых за интерфейсом `ILogAppender`, не зная об их конкретном типе. Именно логгер контролирует формирование сообщения и передачу его для сохранения всем экземпляром аппендеров.

![Logger](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch05_Image2.png)
Рисунок 5.2 - Высокоуровневый дизайн логгера

Однако мы не всегда можем обеспечить передачу управления лишь сверху вниз по слоям приложения. Классы бизнес логики могут потребовать что-то от слоя пользовательского интерфейса. Инфраструктурному коду может потребоваться информация, недоступная на его уровне абстракции. Иногда классы вынуждены "зависеть" от чего-то, что находится вне поля их зрения.

### Наблюдатели

Классическим решением задачи связи нижних слоев с верхними является паттерн Наблюдатель (*). Классу достаточно потребовать от "верхнего уровня" делегат, который он будет использовать по мере необходимости. При этом логически, управление будет передано с нижнего уровня на верхний, однако знать о том, "кто" и "что" будет происходить при вызове этого делегата, текущий класс не будет.

(*) СНОСКА: дать ссылку на главу с Наблюдателем.

```csharp
public class Model
{
  // с помощью этого делегата модель сможет общаться с пользователем
  private readonly Func<bool> _askUser;
  public Model(Func<bool> askUser)
  {
    _askUser = askUser;
  }
}
```

TODO: МОЖЕТ БЫТЬ РИСУНОК!? Как считаете? Тоже самое, но в визуальном представлении?

Хорошим примером использования наблюдателей для передачи управления снизу вверх по слоям приложения является паттерн MVC ((Model-View-Controller, Модель-Представление-Контроллер)). Каждый класс в этом паттерне отвечает за отдельный аспект функционирования: Модель определяет бизнес правила, Вид отвечает за пользовательский интерфейс, а Контроллер обрабатывает входные воздействия и отвечает за логику приложения.

![Image 5-3](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch05_Image3.png)
Рисунок 5.3 - Паттерн Модель-Представление-Контроллер

Классы моделей могут требовать что-то от вышестоящих слоев. Но поскольку слои нижнего уровня не должны знать напрямую о классах верхнего уровня, то данное "общение" осуществляется с помощью наблюдателей. Так, Модель не знает ничего о Контроллере и Представлении и общается с ними опосредованно с помощью Наблюдателей. Паттерн MVC несколько нарушает данное правило и Контроллер обычно знает о пользовательском интерфейсе больше, чем нам бы того хотелось. Контроллер также обрабатывает входные данные от пользовательского интерфейса, что делает этот паттерн сложным для использования в не-веб приложениях.

Чтобы справиться с этими особенностями, возник другой паттерн, под названием - MVP (Model-View-Presenter, Модель-Представление-Презентер).

![Image 5-4](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch05_Image4.png)
Рисунок 5.4 - Паттерн Модель-Представление-Презентер

Главное отличие между паттернами MVP и MVC в том, что Презентер не обрабатывает входные данные пользователя, а также то, как он взаимодействует с Представлением. Презентер знает лишь об абстрактном представлении (IView), интерфейс которых может быть объявлен на его уровне, а реализован - уровнем выше, на уровне представления.

Помимо двух вышеперечисленных паттернов, существует еще один паттерн из семейства MVx - MVVM (Model-View-View Model, Модель-Представление-Модель представления). MVVM похож на MVP, однако вместо интерфейсов `IView` Модель представления "общается" с верхним уровнем с помощью событий, спрятанных в инфраструктурном коде за технологией привязки данных (Data Binding).

### Для чего нужен принцип инверсии зависимостей
*Принцип инверсии зависимостей предназначен для устранения прямых связей между низкоуровневыми классами или модулями с их высокоуровневыми "владельцами".*

![Image 5-5](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch05_Image5.png)
Рисунок 5.5 - Принцип инверсии зависимостей

Название принципа отражает нетипичность направления зависимостей: в данном случае классы нижнего уровня определяют некоторый "контракт", которому должны следовать классы верхнего уровня. Принцип инверсии зависимостей позволяет общаться с модулями верхнего уровня, не зная об их существовании. При этом вместо "слаботипизированных" наблюдателей, текущий класс выделяет именованную зависимость в виде интерфейса, и требует ее наличие в своем конструкторе.

```csharp
// HighLevel.dll
class HighLevelClass : IDependency
{
  private readonly LowLevelClass _lowLevelClass;

  public HighLevelClass()
  {
    _loWLevelClass = new LowLevelClass(this);
  }

  void IDependency.NotifyUpperLevel()
  {
    // Обрабатываем уведомление от нижнего уровня
  }
}

// LowLevel.dll
public interface IDependency
{
  void NotifyUpperLevel();
}

public class LowLevelClass
{
  private readonly IDependency _dependency;

  public LowLevelClass(IDepdency depenency)
  {
    _dependency = dependency;
  }
}
```

Принцип инверсии зависимостей ослабляет связь между уровнями приложения, или же между классами, расположенными на разных уровнях абстракции.

### Остерегайтесь неправильного понимания DIP
Чрезмерное или необдуманное использование любого принципа проектирования может привести к переусложненному дизайну и принцип инверсии зависимостей здесь не  исключение. Распространение библиотек управления зависимостями - IoC-контейнеров, (*) может привести к выделению чрезмерного количества интерфейсов, что делает решение настолько "слабосвязным", что разобраться в нем становиться практически невозможно.

(*) СНОСКА: IoC-контейнеры (Inversion of Control Containers) представляют собой библиотеки для автоматического управления зависимостями. Их главным действующим лицом является контейнер, который сможет создавать экземпляры любого типа в приложении. Для этого контейнер конфигурируется в точке входа (Entry Point) приложения путем задания ассоциации между интерфейсами и их реализацией. Теперь, если пользователь попросит у контейнера экземпляр некоторого типа, то контейнер самостоятельно "найден" все его зависимости и передаст их требуемому классу в параметрах конструктора. IoC-контейнеры являются чрезвычайно полезной и функциональной штуковиной, с обилием дополнительных возможностей. Подробнее о них можно почитать в книге Марка Сиимана "Dependency Injection in .NET".

Причина неправильного использования принципа инверсии зависимостей кроется в недопонимании его целей, а также в описании этого принципа его автором - Робертом Мартин. Вот что он пишет в своей книге [Martin2006]:

> DIP выражается простым эвристическим правилом: «Зависеть надо от абстракций». Оно гласит, что не должно быть зависимостей от конкретных классов; все связи в программе должны вести на абстрактный класс или интерфейс.

> * Не должно быть переменных, в которых хранятся ссылки на конкретные классы.
> * Не должно быть классов, производных от конкретных классов.
> * Не должно быть методов, переопределяющих метод, реализованный в одном из базовых классов.

И далее:
> Конечно, эта эвристика хотя бы раз да нарушается в любой программе. … В большинстве систем класс, описывающий строку, конкретный. Такой класс изменяется редко, поэтому в прямой зависимости от него нет никакой беды. Однако конкретные классы, являющиеся частью прикладной программы, которые пишем мы сами, в большинстве случаев изменчивы. Именно от таких конкретных классов мы и не хотим зависеть напрямую. Их изменчивость можно изолировать, скрыв их за абстрактным интерфейсом.

Буквальное следование принципу DIP по такому описанию чревато серьезными последствиями для дизайна. Выделение абстрактного интерфейса имеет свою цену и мы должны точно понимать, для чего мы это делаем. В последнее время легко столкнуться с проблемой чрезмерно "абстрактных" решений, когда интерфейсов слишком много, и решение настолько "гибкое" и "слабосвязное", что просто невозможно понять, кто за что отвечает и откуда начать изучение системы.

#### Тестируемость решения vs. Подрыв инкапсуляции
Сегодня очень часто выделение интерфейсов объясняют необходимостью юнит-тестирования. Дескать, если класс создает свои зависимости самостоятельно, то как же мы сможем протестировать его в изоляции? Если же класс принимает все свои зависимости извне, да еще и в виде интерфейсов, то мы сможем "замокать" (*) все, что угодно и добиться 100% покрытия тестами!

(*) Существует несколько видов объектов-подделок, используемых в юнит-тестах, которые объединяются общим названием "test doubles". Моки (mocks) и стабы (stubs) являются двумя наиболее распространенными видами подделок, которые предназначены для проверки поведения и эмуляции состояния. Далеко не все изоляционные фреймворки разделяют эти два понятия, поэтому многие из них (такие, как Moq), любые подделки называют моками (mocks), что сделало этот термин применимым для описания любых подделок.
Подробнее о разнице между стабами и моками можно прочитать в моей статье "Programming Stuff: Стабы и Моки" (bit.ly/StubsVsMocks)

Проблема такого подхода в том, что он легко может подорвать инкапсуляцию текущего класса! Если зависимость находится на более низком уровне абстракции, то вызывающему коду она будет мало интересна. Пользовательскому интерфейсу не важно, как именно реализована модель, и какая именно инфраструктура используется двумя слоями ниже. А слою бизнес-логики вряд ли интересны подробности реализации доступа к базе данных. (TODO: последний пример - не оч!) С "колокольни" высокого уровня бывает просто невозможно решить, а что же нужно передать в качестве `IPartitioningStrategy` нашей модели, и почему вообще меня это должно интересовать?

Исходный смысл принципа инверсии зависимостей в том, чтобы классы нижнего уровня взаимодействовали с верхним уровнем косвенно, ничего не зная о нем конкретного. Но он совершенно не означает, что теперь классы верхнего уровня должны знать о всех внутренних проблемах нижележащих слоев.

Просто представьте себе, что вам бы пришлось передавать `IGrowingStrategy` объекту `List<T>` для указания политики увеличения размера списка, или I `IBucketCreationPolicy` объекту `Dictionary<T>` для задания политики создания внутренностей хэш-таблицы (TODO: еще пример?).

Существует несколько причин, почему класс может требовать зависимость в виде аргумента конструктора или метода:
* Поскольку реализация зависимости находится на более высоком уровне (следование принципу DIP).
* Существует множество реализаций зависимости и класс на этом уровне не может решать, какой из них выбрать (следование принципу Открыт-Закрыт).
* Поведение зависимости может быть завязано на внешнее окружение - файлы, базу данных, сокеты.

В первых двух случаях класс самостоятельно не может решить, какой конкретный тип зависимости использовать, поэтому просит "верхний" уровень помочь ему в этом. Последний случай более специфичен. Иногда мы можем осознанно пожертвовать инкапсуляцией в угоду тестируемости, особенно при наличии сложной логики в текущем классе и невозможности разделить его на более простые составляющие для тестировании их в изоляции.

Предположим, мы пишем класс чтения конфигурации, который читает ее из файла. Использование классов `File` или `FileStream` напрямую не позволит протестировать наше решение без внешнего окружения. В этом случае мы можем модифицировать наш класс, чтобы вместо имени файла принимать сразу же поток ввода-вывода (экземпляр `Stream`):

```cshap
public class ConfigurationReader
{
  private readonly Stream _stream;

  public ConfigurationReader(Stream stream)
  {
    _stream = stream;
  }

  public Configuration Read()
  {
    // Используем _stream для чтения конфигурации
  }
}
```

Теперь мы сможем в тестах использовать `MemoryStream` с требуемым содержимым, чтобы проверить основные граничные условия реализации. Данное решение часто используется на практике, но у него есть несколько особенностей. Во-первых, можно подумать о том, чтобы скрыть "тестируемость" от клиентов. Можно сделать конструктор, принимающий `Stream` внутренним, и добавить открытый конструктор или фабричный метод, принимающий имя файла:

```csharp
  internal ConfigurationReader(Stream stream)
  {}

  pulbic static ConfigurationReader Create(string fileName)
  {
    using (var fileStream = new FileStream(path, FileMode.Open))
    {
	    return new ConfigurationReader(fileStream);
    }
  }
```

Во-вторых, нужно обязательно протестировать реализацию `ConfigurationReader`, работающую с файлом в интеграционных тестах (*). В юнит-тестах мы можем хорошо проверить логику, но вряд ли сможем хорошо протестировать граничные условия, возможные при работе с настоящими файлами: проверить вопросы безопасности, отсутствия файла и другие ошибки, возможные при работе с файлами. Обилие интерфейсов и 100% покрытие кода юнит-тестами не гарантирует отсутствие ошибок в реальном окружении.

(*) ВРЕЗКА: *Юнит-тесты vs. Интеграционные тесты*
Существуют разные точки зрения на то, что считать юнит-тестом (модульным тестом), а что считать интеграционным тестом. Хорошее определение юнит-теста можно найти в статье Мартина Фаулера: http://martinfowler.com/bliki/UnitTest.html. Главное отличие интеграционного теста в том, что они проверяют поведение тестируемого кода с реальным окружением - файлами, реальными сетевыми операциями или базами данных. Это делает их более хрупкими: их поломка не означает наличие ошибок в коде, а тажке увеличивает время их исполнения. TODO: возможно, расписать подробнее!

Использование напрямую классов, работающих с файлами, сокетами, базой данных и т.п. в бизнес-коде приложения может быть проблематичным. Инфраструктурные классы являются низкоуровневыми и должны использоваться в инфраструктурном слое или низкоуровневых сервисах. Нет смысла выделять интерфейс `IFileStream` и передавать его через конструктор десятку классов. Интерфейс работы с файлами является низкоуровневым и не должен использоваться в слоях бизнес-логики или логики приложения. Чтение из файла является может быть частью реализации высокоуровневого кода, но тогда, вместо выделения интерфейса работы с файлами, лучше выделить некоторую высокоуровневую стратегию, например, `IConfigurationReader` или `ICustomDataProvider`, одна из реализаций которых будет получать нужные данные из файла.

### Управление зависимостями
> Приложите все усилия, чтобы вы управляли зависимостями в коде, а не они управляли вами.

Programming Stuff: "Управление зависимостяси" (bit.ly/DependencyManagementArticle)

Принцип инверсии зависимостей лежит в основе более общей задачи, с которой сталкивается разработчик - задачей управления зависимостями классов и модулей. Существует несколько критериев, которые нам следует держать в голове при проектировании новых классов и модификации существующих.

**Минимизация зависимостей**

Класс должен зависеть от минимального числа внешних классов. Если классу нужен провайдер работы с базой данных, конфигуратор, прокси к удаленному серверу и формирователь отчетов, то это явно говорит о том, что класс делает слишком многое. Если нарисовать в голове или на бумаге диаграмму объектов, то экземпляр рассматриваемого класса не должен выглядеть пауком, сидящем в центре паутины. Мы должны получить класс с понятным набором зависимостей, многие из которых будут появляться и изменяться в процессе работы. При этом очень полезно различать зависимости нижнего уровня, которые класс может создавать самостоятельно, и зависимости верхнего уровня (иногда и текущего уровня), которые будут передаваться ему через аргументы конструктора.

**Сделать ключевые зависимости класса явными**

Основная проблема использования паттерна Синглтон (*) в том, что читая "заголовок" некоторого класса совсем не очевидно число его зависимостей. Даже если вы вынуждены использовать синглтон, то сделайте его использование явным: инициализируйте поле в конструкторе, но не используйте сам синглтон непосредственно в месте использования:

(*) Сноска: дать ссылку на паттерн Синглтон.

```csharp
class SingletonClient
{
  private readonly Singleton _singleton;
  public SingletonClient()
  {
    _singleton = Singleton.Instance;
  }

  public void Foo()
  {
    // Используем поле _singleton, а не Singleton.Instacen
  }
}
```

Внешние зависимости класса по своему определению должны контролироваться вызывающим кодом, поэтому их использование должно быть максимально явным. Поэтому если классу требуется подключение к базе данных для своей работы, то лучше принимать ее через аргументы конструктора, а не протягивать эту зависимость через глобальные объекты. Когда ключевых зависимостей станет слишком много (больше 4-х), то это сразу же станет сигналом к тому, что часть из них не главные, они слишком низкоуровневые и должны быть объединены в более высокоуровневые сущности, или же наш класс стал слишком сложным.

**Сделать класс тестируемым**

Обычно, невозможность протестировать некоторую функциональность класса говорит о проблемах в его дизайне. Если вы не можете протестировать процесс разбора данных, поскольку они читаются из файла, то, возможно, стоит выделить обязанности разбора данных в отдельный класс. Но иногда лишь некоторая часть класса работает с внешним окружением и в этом случае полезно выделить данную обязанность в отдельный класс и отвязаться от нее за интерфейсом.

Но важно понимать, что дробление классов на слишком больше количество может усложнить понимание кода. А также то, что мы не можем абстрагироваться от внешнего окружения до бесконечности. Если мы реализуем класс `FileStream`, то мы не можем выделить дополнительный интерфейс для обеспечения тестируемости. В этом случае нам придется использовать интеграционные тесты, или такие инструменты, как Shims из Microsoft Fakes, которые позволяют перехватить и "замокать" любые методы, а не только виртуальные (*).

(*) Сноска: Шимы предоставляют возможность подменить поведение любого метода, включая статические и/или закрытые методы библиотеки BCL. Использование этого инструмента для юнит-тестирования должно быть последним вариантов, когда ни один другой способ обеспечения тестируемости класса не подходит. TODO: возможно стоит рассказать об этом подробнее.

### Примеры нарушения принципа инверсии зависимостей
* Низкоуровневые классы напрямую общаются с высокоуровневыми классами: модели знают о пользовательском интерфейсе или инфраструктурный код знает о бизнес-логике.
* Низкоуровневые классы используют множество наблюдателей для взаимодействия с верхним уровнем. Использование делегатов подходит для простой связи класса с внешним окружением, но если их становится много, то значительно лучше объединить их в интерфейс, с понятным названием и предполагаемым поведением.

### Заключение
"Простое эвристическое правило, что зависеть нужно от абстракций", на деле оказалось более сложным, чем могло показаться изначально.

Принцип инверсии зависимостей объясняет, почему некоторые зависимости должны передаваться классу через конструктор в виде интерфейсов, и почему мы не можем использовать их напрямую. Классы имеют право контролировать свои детали реализации, но некоторые аспекты, находятся за пределами их компетенции. Чтобы не завязываться на классы верхнего уровня, класс может объявить некоторый интерфейс, и потребовать его во время создания. Это позволит ему позднее "общаться" с внешним миром, не зная о нем ничего конкретного.
