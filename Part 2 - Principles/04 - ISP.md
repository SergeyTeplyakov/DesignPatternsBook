## Глава 5. Принцип разделения интерфейсов
TODO: добавить цитату

**Принцип разделения интерфейсов** (Interface Segregation Principle, ISP): _клиенты не должны вынужденно зависеть от методов, которыми не пользуются._
Роберт Мартин. "Принципы, паттерны и практики гибкой разработки" [Martin2006]

Необходимым условием повторного использования кода является простота его использования. Разработчик никогда не будет использовать чужой код, если ему проще реализовать эту возможность самостоятельно, чем найти и разобраться в чем-то решении. С одной стороны, программисты достаточно ленивы и не склонны делать больше, чем того требует задача, но, с другой стороны, они достаточно горды и упрямы, чтобы считать любое чужое решение по определению менее удачным, чем свое собственное.

Синдром "я бы сделал это не так" является самым главным камнем претктновения во время рецензирования кода. Этот же синдром останавливает многих разработчиков от использования чужого кода. На своем горьком опыте разработчики уяснили, что разработка повторноиспользуемого кода - дело сложное. Поэтому они нечасто используют чужой код, но активно продвигают повторное использование своего собственного кода.

Одной из причин скептического отношения к повторноиспользуемому коду заключается в сложности проектирования библиотек, простых в использовании. С одной стороны, библиотека должна решать базовые вещи простым и интуитивно понятным способом. С другой стороны, она должна делать возможными и более сложные сценарии. Одним из способов добиться простоты использования кода заключается в проектировании "чистых" интерфейсов: интерфейсов, которые предоставляют цельный набор операций, который будет необходим большинству клиентов.

Кржиштоф Квалина и Брэд Абрамс в своей книге "Framework Design Guidelines" приводят замечательный график зависимости сложности решения от сложности решаемой задачи:

![Image4.1](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch04_Image1.png)
Рисунок 4.1 - Зависимость сложности решения от сложности задачи
(TODO: тотально не уверен, что отступление и этот рисунок вообще нужен!!)

### Для чего нужен принцип разделения интерфейса?
Принцип разделения интерфейса предназначен для получения простого и слабосвязного кода. Он гласит, что клиенты должны зависеть лишь от тех методов, которые они используют, и не должны знать о существовании не интересующих их частей в интерфейсе используемых ими сервисов. Как мы увидим позднее, разработчик сервиса не всегда знает о том, кто и как его будет использовать. Поэтому может потребоваться несколько итераций, чтобы перегруппировать методы таким образом, чтобы их использование было удобным максимальному числу клиентов.

Данный принцип является частным случаем принципа наименьшего знания, который много лет используется в нашей индустрии. Для получения простого в сопровождении кода, каждый класс должен знать минимум информации об окружающем коде, необходимой для решении своей задачи. На практике это проявляется в минимизации числа зависимостей и в стремлении к использованию наиболее простых типов зависимостей.

Простота и сопровождаемость классов определяется числом исходящих связей (зависимостей), а также типом зависимостей. Чем сложнее зависимость текущего класса, тем более вероятной является ее изменение, которая может привести к изменениям или поломке текущего класса. Слжоность зависимости определяется числом методов (чем больше методов, тем, в общем случае, зависимость сложнее), а также ее стабильностью. Ниже представлены виды зависимостей, стабильность которых уменьшается от "очень стабильной" до "нестабильной":

- Примитивные типы.
- Объекты-значения (неизменяемые пользовательские типы).
- Объекты со стабильным интерфейсом и поведением (пользовательские типы интерфейс которых стабилен, а поведение не зависит от внешнего окружения).
- Объекты с изменчивым интерфейсом и поведением (типы расположены на стыке модулей, которые постоянно подвергаются изменениям или типы, которые работают с внешним окружением: файлами, базами данных, сокетами и т.п.). (*)

(*) СНОСКА или ПРИМЕЧАНИЕ: мы тут затронули очень сложную тему проектирования, связанную с управлением зависимостями. Это весьма сложная тема, которая требует нескольких глав или даже целой книги. В качестве дополнительных источников по этой теме может служить книга Марка Симана "Dependency Injection in .NET", и цикл моих статей по управлению зависимостями - http://bit.ly/DependencyManagement.

Принцип разделения интерфейсов также соответствует одному из принципов контрактного программирования: **требуй меньше, но гарантируй больше**. В терминах контрактов это проявляется в виде использования более слабого предусловия и более строгого постусловия. Чем проще аргументы метода, тем проще удовлетворить предусловиям метода. На практике это правило выражается в виде использования наиболее простых типов (согласно приведенной выше шкалы), а также в использовании наиболее базовых типов в качестве аргументов:

```csharp
public Result Process1(List<RequestArgs> input)
{
  foreach(var ra in input)
  {
    // ...
  }
}

public Result Process2(IEnumerable<RequestArgs> input)
{
  foreach(var ra in input)
  {
    // ...
  }
}
```

Если метод использует лишь члены интерфейса `IEnumerable<T>`, то нет смысла заявлять, что он требует `List<T>`. Если метод может работать с любым потоком ввода-вывода, то лучше ему принимать `Stream`, а не `MemoryStream`. Если классу требуется конфигурация, то лучше передавать в аргументах конструктора экземпляр класса `Configuration` (объект-значение), а не провайдер `IConfigurationProvider`, который будет читать конфигурацию в методе `ReadConfiguration`.

**ПРИМЕЧАНИЕ**
В случае с коллекциями и последовательностями нужно очень обдуманно подходить к выбору типа аргументов. Часто бывает, что в качестве аргумента используется `IEnumerable<T>`, но при этом рассчитывается на то, что будет передаваться коллекция в памяти. Например, метод может несколько раз вызывать метод расширения `Count()`, в расчете на то, что он будет выполняться быстро, поскольку передается в метод лишь список или массив. Это является примером "неявной связи" (implicit coupling) и может привести к серьезным проблемам при сопровождении, когда в качестве аргумента метода начнет передаваться последовательность, генерируемая на лету с помощью блока итераторов.

### SRP vs. ISP
Принцип разделения интерфейсов является довольно простым и очень полезным принципом проектирования. Но его иногда путают с принципом единой обязанности. Причина такого недопонимания лежит в классическом описании ISP [Martin2006]:

> Этот принцип относится к недостаткам "жирных" интерфейсов. Говорят, что класс имеет жирный интерфейс, если функции этого интерфейса недостаточно сцепленные (not cohesive). Иными словами, интерфейс класса можно разбить на группу методов. Каждая группа предназначена для обслуживания разных клиентов. Одним клиентам нужна одна группа методов, другим – другая.

Проблема этого определения в том, что в нем делается акцент на жирности. «Жирный» интерфейс, который содержит несколько групп методов, недостаточно сцепленных между собой нарушают принцип единой обязанности. Такие методы используются разными клиентами и будут развиваться независимым образом. Однако все не так просто.

Давайте вспомним, как мы определяем, что класс или модуль нарушает принцип единой обязанности. Мы открываем исходный код этого класса или модуля, и смотрим, не делает ли он слишком многого. Если класс или модуль отвечает за выполнение разнородных задач, значит он однозначно нарушает принцип единой обязанности. Но можем ли мы глядя на класс или его интерфейс сказать, нарушает он принцип разделения интерфейса или нет?

Вот, например, у нас есть класс репозитория, который содержит CRUD операции (*). Нарушает ли он ISP? Мы не знаем! Нарушение этого принципа зависит не столько от самого класса, сколько от сценариев его использования. Если в нашей бизнес-модели четко разделяются операции чтения и обновления данных, то наличие одного класса со всеми операциями по работе с данными однозначно делает интерфейс слишком толстым. С другой стороны, если наше приложение содержит множество простых форм пользовательского интерфейса, которые соотносятся 1 к 1 с нашими поставщиками данных, то тогда принцип ISP не нарушается.

(*) СНОСКА: CRUD - Create, Read, Update, Delete, набор ключевых операций при работе с постоянными хранилищами данных, такими как база данных.

Из предыдущего обсуждения следует важное отличие принципов SRP и ISP. **Следование принципу единой обязанности приводит к связанным (cohesive) классам, что позволяет с меньшими усилиями их понимать и развивать. Следование принципу разделения интерфейсов уменьшает связанность (coupling) между классами и его клиентами, ведь теперь клиенты используют более простые зависимости, чем раньше.**

### Множественная реализация интерфейсов
Даже если не все разработки хорошо понимают принцип разделения интерфейсов, но каждый программист C# или Java постоянно им пользуется. **Любой класс в языке C# (или Java), который реализует более одного интерфейса следует принципу ISP!**

Классы часто реализуют более одного интерфейса, когда у него есть несколько клиентов или аспектов поведения:
* Один интерфейс нужен классу для работы с некоторым фреймворком, а другой – определяет бизнес-функциональность.
* Класс может реализовывать несколько аспектов одной и той же функциональности, которые используются по-разному в разных контекстах.
* Класс может реализовывать ролевой интерфейс (Role Interface), такой как `IComparable`, что добавляет определенный аспект поведения, требуемый лишь в определенном контексте, например, для сортировки объектов в 'SortedList<T>'.
* Иерархия классов может содержать несколько проекций: основное поведение выражается в виде наследования классов, а вспомогательное общее поведение моделируется путем "подмешивания" дополнительных интерфейсов разным конкретным классам.

В плагине для поддержки контрактного программирования принцип разделения интерфейса применяется неоднократно.
TODO: пример мне не очень нравится! Подумать/обсудить это дело!

Одной из задач этого плагина является отображение проблемных контрактов с возможностью автоматического устранения некоторых проблем с помощью контекстных действий (Quick Fixes). Инфраструктура ReSharper требует, чтобы каждой ошибке или предупреждению соответствовал свой класс, реализующий интерфейс `IHighlighting`. При этом  многие ошибки или предупреждения могут содержать схожую логику исправления. Совмещение двух этих аспектов - отображения проблемы и ее устранение, решается путем множественного наследования интерфейсов:

![Image4.2](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch04_image2.png)
Рисунок 4.2 - Множественная реализация интерфейсов

Классы ошибок (`CodeContractErrorHighlighting`) и предупреждений (`CodeContractWarningHighlighing`) имеют два вида клиентов: (1) инфраструктуру ReSharper и (2) классы, исправляющие проблему. В результате, классы предупреждений реализуют два интерфейса `IHighlighting` и `ICodeContractFixableIssue`, соответственно.

Множественное наследование также бывает полезно при проектировании сложных иерархий. Иерархия наследования позволяет сгруппировать общее поведение в базовых классах, и реализовать специфическое поведение в наследниках. Но часто бывает, что нам требуется несколько способов "группировки" базового поведения. В языках без множественного наследования решение заключается в добавлении конкретным классам дополнительных поведенческих интерфейсов.

Именно с такой проблемой группировки я столкнулся при моделировании иерархии контрактных утверждений. В более общем виде, контракты в языке C# могут быть представлены не только с помощью методов класса `Contract`, но и с помощью обычных конструкций, например, `if-throw`. В результате нескольких итераций я пришел к следующей иерархии наследования:

![Image4.3](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch04_Image3.png)
Рисунок 4.3 - Иерархия контрактных операторов
Классы ContractRequires одновременно является "утверждением библиотеки Code Contract" - наследует классу `CodeContractAssertion`, а также является предусловием - реализует интерфейс `IPrecondition`. Такое разделение позволяет использовать экземпляры одного и того же типа полиморфным образом в разных контекстах.

### Когда выделять интерфейсы?

Прежде чем изменять дизайн своего решения согласно некоторому принципу нужно понимать, какие проблемы решает принцип, и в каких случаях ему нужно следовать, а когда нет. Выделение интерфейса класса (*) добавляет дополнительный уровень абстракции, что имеет свои преимущества и недостатки. Ниже представлены причины выделения у класса одного или нескольких интерфейсов:

(*) СНОСКА: здесь речь идет о выделении .NET интерфейса класса.

Во-первых, может появиться необходимость выделить интерфейс для класса целиком. Это бывает необходимым для "изменчивых" зависимостей (*) - классов, чье поведение изменяется в зависимости окружения, или для стратегий - когда нам по определению нужно полиморфное поведение, изменяемое во время исполнения.

TODO: У Симана в его курсе Encapsulation and Solid есть интересная мысль, что выделять интерфейсы нужно лишь когда есть более 2-х реализаций! Тогда понятен "вектор внесения изменений", и мы не столкнемся с проблемой преждевременного обобщения. У него есть принцип даже [статья](http://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/), в которой он говорит о принципе "Reuse Abstraction Principle". Мысли интересные, но не уверен, стоит ли об этом писать или нет!

(*) СНОСКА: Понятия стабильных (stable) и изменчивых (volatile) зависимостей отлично описаны в замечательной книге Марка Симана "Dependency Injection in .NET". Также о них можно прочитать в моей статье "Управление зависимостями" - http://bit.ly/DependencyManagementArticle.

Во-вторых, мы можем выделить некий аспект текущего класса, который покрывает не весь функционал, а лишь его часть. Примером может служить добавление классу «ролевых» интерфейсов (Role Interface), таких как `ICloneable`, `IComparable<T>`, `IEquatable<T>` и т.п. При этом выделение таких интерфейсов обычно требуется для использования класса в новом контексте: например, класс `Person` может реализовывать интерфейс `IComparable<Person>` для корректного хранения экземпляров в `SortedList`.

В-третьих, может потребоваться выделение специализированных бизнес-интерфейсов, когда станет очевидным, что наш класс используется в нескольких разных контекстах. Например, когда репозиторий используется разными клиентами двумя способами: одна группа клиентов использует лишь операции для чтения данных, а другая группа – для обновления. Обычно это говорит не столько о нарушении принципа разделения интерфейсов, сколько о наличии скрытой абстракции (`IRepositoryReader` и `IRepositoryWriter`).

В-четвертых, нам может потребоваться использовать несколько разных классов из разных иерархий наследования полиморфным образом. При этом обычно такое выделение происходит во время рефакторинга, когда необходимость в этом становится очевидной.

### Типичные примеры нарушения ISP
* Метод принимает аргументы производного класса, хотя достаточно использовать базовый класс.
* Класс зависит от более сложной зависимости, чем нужно: принимает изменчивую зависимость, хотя нужен результат ее работы и т.п.
* Класс зависит от сложного интерфейса, завязываясь неявно на все типы аргументов всех методов.

### Заключение

Принцип разделения интерфейсов является частным случаем управления зависимостями и борьбы со сложностью. Чем проще зависимости класса, тем проще его понимать и тем меньше вероятность его изменения из-за изменений в других частях системы.

Принцип разделения интерфейсов лежит на стыке классов или модулей. Глядя на исходный код некоторого класса мы можем сказать, соответствует ли реализация принципу единой ответственности, принципу замещения Лисков или принципу открыт/закрыт. Но лишь по исходному коду класса или его интерфейса мы не можем судить о том, следует ли он принципу разделения интерфейсов или нет. Для этого нам нужно посмотреть контекст его использования: есть ли разные группы клиентов, которые используют его по разному, или нет?

Если класс или интерфейс используется по разному в разных контектсах, то, возможно, его стоит разбить на несколько более "цельных" составляющих.
