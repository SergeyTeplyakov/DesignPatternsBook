# Паттерн Заместитель (Proxy)

**Назначение:** является суррогатом другого объекта и контролирует доступ к нему.

## Мотивация

Изменение требований и эволюция системы могут потребовать внесения серьезных архитектурных изменений. Если на ранних этапах некоторая операция выполнялась на стороне клиента, или же приложение состояло из одного процесса, то, со временем, исполнение операции может быть перенесено на сервер, а приложение - разбито на несколько процессов.

В результате, возникает задача взаимодействия с удаленным процессом, реализация которой должна быть максимально похожей на локальное взаимодействие. Именно для таких целей предназначен паттерн Заместитель.

В случае с приложением по импорту лог-файлов, его разработчики могут прийти к заключению, что прямая работа с удаленным хранилищем является неудачным решением, и необходимо выделить отдельный сервис для сохранения данных. При использовании современных библиотек, таких как WCF, ASP.NET Web API или .NET Remoting, сделать такой переход будет не сложно.

При использовании WCF, старый интерфейс `ILogSaver` и все объекты, используемые в качестве аргументов и возвращаемых значений, нужно декорировать специальными атрибутами (`ServiceContract` + `OperationContract` и `DataContract` + `DataMember`).
Затем, нужно сконфигурировать приложение, добавив в его конфигурационный файл информацию о привязках (binding), контрактах (contracts) и точках доступа (endpoint). После чего останется создать простой класс-заместитель (или прокси-класс) и пользоваться им так, как будто реализация `ILogSaver` находится в этом же процессе (*):

(*) Сноска: как будет показано ниже, полностью игнорировать распределенную природу не следует, поскольку это может привести к негативным последствиям. Распределенное взаимодействие налагает слишком большое число дополнительных ограничений, игнорировать которые опасно.

```csharp
class LogSaverClient : ClientBase<ILogSaver>, ILogSaver
{
    public void SaveLogEntry(LogEntry logEntry)
    {
        // Делегируем всю работу внутреннему свойству Channel,
        // с типом ILogSaver
        Channel.SaveLogEntry(logEntry);
    }
}

//...
public void SaveLogEntryAtTheBackend(LogEntry logEntry)
{
    var proxy = new LogSaverClient();
    proxy.SaveLogEntry(logEntry);
    proxy.Close();
}
```

Листинг 5.1 - Пример использования класса-заместителя для работы с WCF

Основная "магия" находится в классе `ClientBase<T>` и нижележащей инфраструктуре WCF, которая отвечает за сериализацию аргументов, передачу их "по проводам" и десериализацию ответа. Класс `LogSaverClient` является классом-заместителем, который позволяет работать с удаленным WCF сервисом так, как будто экземпляр `ILogSaver` находится в текущем процессе. 

## Классическая диаграмма классов паттерна Заместитель

![Рисунок4.2](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%203%20-%20Structural%20Patterns/Images/ch05_Image1.png)    
Рисунок 5.1 - Классическая диаграмма классов паттерна Заместитель

**Участники**

* `Client` работает с абстрактным компонентом, не зная, является ли он настоящим или нет.

* `Subject` (`ILogSaver`) определяет интерфейс компонента.

* `Proxy` (`LogSaverClient`) - объект-заместитель, который реализует интерфейс компонента, но делегирует всю работу настоящему объекту.

* `RealSubject` - реальный компонент, доступ к которому осуществляется через заместитель.

## Обсуждение паттерна Заместитель

Заместитель является одним из немногих паттернов проектирования, который с течением времени претерпел довольно серьезные изменения. В классическом труде "банды четырех" описаны три основных сценария использования паттерна Заместитель:

* **Удаленный заместитель** отвечает за кодирование запроса и его аргументов для работы с компонентом в другом адресном пространстве.

* **Виртуальный заместитель** может кэшировать дополнительную информацию о реальном компоненте, чтобы отложить его создание.

* **Защищающий заместитель** проверяет, имеет ли вызывающий объект необходимые для выполнения запроса права.

Второй и третий варианты паттерна Заместитель применяются на практике, но своей известностью этот паттерн обязан первому варианту. Классы-заместители являются стандартным паттерном в подавляющем большинстве современных технологий построения распределенных приложений. Однако, внешний вид классов-заместителей и подходы к их реализации за последние 15 лет претерпели очень серьезные изменения.

## Прозрачный удаленный Заместитель
Основная идея удаленного заместителя заключается в том, что клиент может работать с классом-заместителем так, как будто он работает с объектом в своем собственном адресном пространстве. Этот подход настолько понравился разработчикам распределенных технологий конца 90-х начала 2000-х, что многие технологии того времени постарались стереть грань между внутрипроцессным и межпроцессным взаимодействием. Такой подход получил название *прозрачность местоположения* (location transparency) и лег в основу таких технологий, как DCOM и .NET Remoting.

Однако, со временем, разработчики начали осознавать, что постоянно сталкиваются с проблемами "дырявых абстракций" и не могут игнорировать особенности сетевого взаимодействия. Особенности обработки ошибок, необходимость, чтобы все параметры методов были сериализируемыми, задержки и длительное время исполнения методов, все это требует другого подхода с точки зрения разработки (*). Поэтому в последних технологиях, таких как WCF и ASP.NET Web API, классы-заместители перестали быть "прозрачными". Разработчик может работать с интерфейсом `ISomeInterface`, каждый вызов которого исполняется на удаленной стороне, но программисту самому придется стереть грань между распределенным и локальным мирами.

(*) Сноска: можно смело говорить, что удаленный заместитель нарушает принцип замещения Лисков. При замене локальной реализации `ILogSaver` удаленным заместителем, поведение приложения обязательно изменится. Изменения коснутся времени исполнения и обработки ошибок. Зачастую, может потребоваться полное перепроектирование клиента `ILogSaver` с учетом его новой удаленной природы.

Такие классы, как `ChannelBase<T>` в WCF, очень сильно упрощают взаимодействие с удаленным процессом, но они, скорее, выполняют роль фасадов, а не классов-заместителей!

### Заместитель vs. Декоратор
Структуры паттернов Заместитель и Декоратор очень похожи. Каждый из них содержит ссылку на базовый компонент и делегирует ему выполнение всей работы. Но у этих паттернов разное назначение.

Декоратор добавляет поведение всем методам интерфейса, позволяя "нанизывать" расширения одно на другое. Класс-заместитель может выполнять определенные действия, например, создавать настоящий компонент по мере требования, но он не должен ничего "подмешивать" в результаты исполнения операции.

### Виртуальный заместитель и `Lazy<T>`
Класс `Lazy<T>` можно считать универсальным строительным блоком, с помощью которого легко создавать виртуальные классы-заместители.

```csharp
public interface IHeavyweight
{
    void Foo();
}

// Стоимость создания класса очень высока
public class Heavyweight : IHeavyweight
{
    public void Foo()
    {}
}

// Виртуальный заместитель, который будет создавать
// тяжеловесный объект лишь в случае необходимости
public class HeavyweightProxy : IHeavyweight
{
    private readonly Lazy<Heavyweight> _lazy = new Lazy<Heavyweight>();

    public void Foo()
    {
        _lazy.Value.Foo();
    }
}
```

Листинг 5.2 - Реализация виртуального заместителя с помощью `Lazy<T>`

## Применимость
Классы-заместители активно применяются там, где нужно спрятать исходный объект и добавить к его методам некоторое поведение: дать возможность отложенного создания дорогостоящего объекта, контролировать количество вызовов метода или спрятать удаленную природу объекта.

## Примеры в .NET Framework

* **Удаленные классы-заместители**.
В коммуникационных технологиях в .NET Framework применяются удаленные прокси-классы: `ChannelBase<T>` в WCF, `RealProxy` в .NET Remoting.

* **Виртуальные классы-заместители в ORM-фреймворках**.
В современных ORM (Object-Relational Mapping, объектно-реляционное отображение), таких как NHibernate или Entity Framework, применяются специализированные виртуальные классы-заместители. ORM генерирует оболочку над сущностями (data entities), чтобы отслеживать изменения и генерировать корректный SQL-код для обновления записей в базе данных.
