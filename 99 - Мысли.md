Структура главы о паттернах:

* Примеры в .NET перенести в самый конец!
* Нужно ли в описании классической диаграммы давать имена классов из рассмотренных примеров?

Мысли и Todo-шки
Где-то бы порассуждать о терминологии: дизайн vs. проектирование

Шаблонный метод

Посмотреть раздел « Don’t call us, we’ll call you» из книги Мейера. Там описан именно такой принцип, и Мейер говорит, что именно он лежит в основе реюзабл кода!
Сделать последний раздел: Принципы проектирования
В котором дать SOLID (взять из статей). Возможно стоит переделать примеры, причесать их под одну гребенку (например, не использовать свой R# Plugin).
В этом разделе, для каждого принципа сделать подраздел: **Применимость принципа в паттернах.**

И там уже дать, что в SRP: Factory Method, Builder or even Builder encapsulated in Factory Method, поскольку сложность растет и обязанность по созданию объекта становится достаточно сложной, чтобы для нее выделить отдельный класс, а иногда, даже иерархию классов, если мы хотим процесс создания сделать расширяемым на лету (вот тебе OCP).

Молодые специалисты обычно ищут рецепт: делай 1, 2, 3 и ты получишь хороший дизайн. Используй фасад с фабрикой, заверни в синглтонную стратегию и твой дизайн будет на 5+. Используй принцип единой обязанности, не забудеть о LSP и все ок.

На деле же все происходит наоборот. Мы дизайним приложение обычным образом, а затем находим в нем паттерны (или немного **изменяем дизайн**, поскольку видим что-то знакомое) и валидируем дизайн исходя из **принципов проектированияC**.

Примеры Chains of Responcibility: AggregateException.Flattern().Handle.

**Проблема выбора примеров**
Тут сказать, что примеры - это вечная проблема. С одной стороны - они должны быть достачно простыми и понятными, и не требовать специализированных знаний у читателя. С другой стороны, невозможно на простых примерах показать использование принципипов проектирования. Дизайн простой задачи требует аккуратности, но не требует строгих подходов и тщательного выбора абстракций.

## Декоратор
Этот же подход использовался для создания "кэширующего декоратора", рассмотренного в статье ["Кэширующий декоратор на деревьях выражений"](http://sergeyteplyakov.blogspot.com/2012/09/blog-post_24.html), а также во многих других случаях, когда нам нужно выполнить множество действий похожим образом.
(Дать связь с Шаблонным Методом на основе делегатов!)

## Null-object pattern
Была мысль добавить его в заключительную главу по паттернам поведения.
Пока выпилил. Вот наброски!

## Null-object паттерн

**TODO: нужен ли он вообще?**

**Назначение**: определяет объект с "неитральным" (пустым) поведением.

Null-object паттерн не был описан "бандой четырех", но его популярность позволяет поставить его в ровень с классическими паттернами поведениями.

Большинство современных объектно-ориентированных языков программирования поддерживают понятие нулевых ссылок (null references или null pointers). Null-object паттерн позволяет использовать специализированного наследника без поведения, который будет использоваться вместо нулевой ссылки, что устранит лишние проверки на `null` и сделает код более выразительным.

![Рисунок7.2](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%201%20-%20Behavioral%20Patterns/Images/ch07_Image04.png)    
Рисунок 7.4 - Диаграмма классов null-object паттерна

Проблема Null-object паттерна кроется в самой его природе. По своему определению, "нулевая реализация" не должна ничего делать

В .NET Framework Null-object паттерн нашел свое применение, но не в классическом виде. 
Вместо классического Null-object паттерна, в .NET Framework довольно часто и

Метод `doSomething` класса `NullEntity` по определению не должен ничего делать, но такое поведение в большинстве случаев будет противоречить Принципу подстановки Лисков. Метод `Save` должен сохранять что-то в постоянно

### Паттерн Частный случай

Null-object паттерн является разновидностью паттерна Частный случай (Special Case pattern).
В .NET-приложениях есть ряд 

Null-object паттерн стоит использовать с осторожностью. Помимо 

В некоторых случаях null-object паттерн (или паттерн Особый случай, special case) являются 

### Краткое описание
Избежать null-dereferncing. Нет смысла использовать так: if (result = result.Empty)
### Примеры использования в .NET Framework

Несколько частных случаев: пустая коллекция, string.empty, EventArgs.Empty. Это позволяет выполнять ряд операций без проверки на null.

В бизнес-коде иногда полезно... Хотя редко. Поскольку легко нарушить LSP! Любые команды наверняка нарушат LSP и постусловия!
Обсуждение паттернов поведения
