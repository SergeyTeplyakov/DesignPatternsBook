# Паттерн Стратегия

**Назначение:** определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Стратегия позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются.

**Другими словами:** стратегия инкапсулирует некоторое поведение с возможностью его подмены.

**Подробнее** : [Strategy Pattern on Wiki](http://en.wikipedia.org/wiki/Strategy_pattern)

## Мотивация

Паттерн стратегия является настолько распространенным и общепринятым, что многие его используют постоянно, даже не задумываясь о том, что это хитроумный паттерн проектирования, расписанный когда-то бандой четырех (*).

(*) СНОСКА: Речь о знаменитой книге о паттернах проектирования, с которой началось 

Каждый второй раз, когда мы пользуемся наследованием, мы используем стратегию; каждый раз, когда мы абстрагируемся от некоторого процесса, поведения или алгоритма за базовым классом или интерфейсом – мы используем стратегию. Сортировка, анализ данных, валидация, разбор данных, сериализация, кодирование, получение конфигурации, все эти концепции могут и должны быть выражены в виде стратегий или политик (policy).

Стратегия является фундаментальным паттерном, поскольку она проявляется в большинстве других классических паттернов проектирования, которые поддерживают специализацию за счет наследования. Абстрактная фабрика – это стратегия создания семейства объектов; фабричный метод – стратегия создания одного объекта; строитель – стратегия построения объекта; итератор – стратегия перебора элементов и т.д. (*)

(*) Подробнее все эти паттерны проектирования будут рассмотрены в последующих главах.

Давайте в качестве примера рассмотрим задачу импорта лог-файлов для последующего полнотекстового поиска (full text search). Главной задачей данного приложения является чтение лог-файлов из различных источников, приведение их к некоторому каконическому виду и сохранение их в некотором хранилище.

TODO: нужно ли выносить описание задачи в отдельный раздел? Например, куда-то в начало книги?!?
![Рисунок1.1](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%201%20-%20Behavioral%20Patterns/Images/ch01_Image1.png)    
Рисунок 1.1 - Диаграмма классов импортера логов

`LogProcessor` отвечает за импорт лог-файлов и должен работать с любой разновидностью логов: файлами, логами ОС Windows и т.д. Для этого, процесс чтения логов выделяется в виде интерфейса или базового класса `ILogReader`, а класс `LogProcessor` отвязывается от конкретной реализации.

**Мотивация использования паттерна Стратегия:** выделение поведения или алгоритма с возможностью его замены во время исполнения.

## Варианты реализации в .NET

В общем случае паттерн Стратегия не определяет, какое количество операций будет у "выделенного поведения или алгоритма". Это может быть одна операция (метод `Sort` интерфейса `ISortable`), а может быть и семейство операций (`Encode`/`Decode` интерфейса`IMessageProcessor`).

При этом, если операция лишь одна, то вместо выделения и передачи интерфейса в современных .NET приложениях очень часто используется передача делегата. Так, в нашем случае, вместо передачи интерфейса `ILogReader` класс `LogProcessor` мог бы принимать делегат вида:`Func<List<LogEntry>>`, который соответствует сигнатуре единственного метода стратегии:

```csharp
class LogProcessor
{  
    private readonly Func<List<LogEntry>> _logImporter;  
    public LogProcessor(Func<List<LogEntry>> logImporter)  
    {
        _logImporter = logImporter;
    }

    public void ProcessLogs()
    {
        foreach(var logEntry in _logImporter.Invoke())
        {
            SaveLogEntry(logEntry);
        }
    }
    // Остальные методы пропущены...
}```

Использование "функциональных стратегий" является единственной платформенно-зависимой особенностью паттерна Стратегия на платформе .NET. Да и то, эта особенность обусловлена не столько самой платформой, сколько возрастающей популярностью техник функционального программирования.

**ПРИМЕЧАНИЕ**  
В некоторых командах возникают попытки обобщить паттерны проектирования и использовать их повторно в виде библиотечного кода. В результате появляются интерфейсы `IStrategy` и `IContext`, вокруг которых строится решение в коде приложения. Есть лишь несколько паттернов проектирования, повторное использование которых возможно на уровне библиотеки: Синглтон, Наблюдатель, Команда. В общем же случае, попытка обобщить паттерны на уровне библиотек приводит к переусложненным решением и скорее показывает непонимание фундаментальных принципов паттернов проектирования.

## Примеры в .NET Framework

Стратегия является невероятно распространенным паттерном в .NET Framework. 

LINQ (Language Integrated Query) – это набор методов расширения, принимающих "стратегии" фильтрации, получения проекции и т.д. Коллекции принимают стратегии сравнения элементов, а значит любой класс, который принимает `IComparer<T>` или `IEqualityComparer<T>` используют паттерн Стратегия.

WCF просто переполнен стратегиями: `IErrorHandler` – стратегия обработки коммуникационных ошибок; `IChannelInitializer` – стратегия инициализации канала; `IDispatchMessageFormatter` – стратегия форматирования сообщений; `MessageFilter` – стратегия фильтрации сообщений и т.д.

Также же обилие стратегий есть в Windows Forms, WPF, ASP.NET и других фреймворках. 

Любая библиотека просто набита стратегиями, поскольку они представляют собой универсальный механизм расширения требуемого функционала пользователем и адаптации поведения под неизвестные зараннее требования.

## Обсуждение паттерна Стратегия

По определению, применение стратегии обусловлено двумя причинами: (1) инкапсуляция поведения или алгоритма и (2) возможность замены поведения или алгоритма во время исполнения. Любой нормально спроектированный класс уже инкапсулирует в себе поведение или алгоритм, но не любой класс с некоторым поведением является или должен быть стратегией. **Стратегия нужна тогда, когда нужно не просто спрятать алгоритм, а когда  важно иметь возможность заменить его во время исполнения!**

TODO: тут - не очень!
Другими словами, стратегия обеспечивает точку расширения системы в определенной плоскости: класс-потребитель стратегии не знает, как выполняется некоторое действие и кто именно его выполняет, и какой вариант реализации он собирается использовать.

### Выделять интерфейс или нет?

Сейчас существует два противоположных лагеря в ОО мире: ярые сторонники выделения интерфейсов и ярые противники этого явления. Когда возникает вопрос о необходимости выделения интерфейса и добавления наследования мне нравится думать об этом, как о необходимости выделения стратегии. Это не всегда точно, но может быть хорошей лакмусовой бумажкой этого процесса.

Нужно ли выделять интерфейс `IValidator` для проверки корректности ввода пользователя? Нужен ли нам интерфейсы `IFactory` или `IAbstractFactory`, или нам подойдет один конкретный класс? Ответы на эти вопрос зависят от того, нужна ли нам "стратегия" (или политика) валидации или создания объектов. Хотим ли мы заменять эту стратегию во время исполнения или мы можем использовать конкретную реализацию и внести в нее изменение в случае необходимости?

У выделения интерфейса и передачи его в качестве зависимости есть еще несколько особенностей. Передача интерфейса `ILogImporter` классу `LogProcessor` повышает гибкость, но и повышает сложность. Теперь, клиенту класса `LogProcessor` нужно решить, какой импортер использовать, или перекладывать эту ответственность на свой вызывающий код.

Важно понимать, нужен ли дополнительный уровень абстракции именно сейчас. Может быть на текущем этапе достаточно использовать напрямую класс `LogFileImporter`, а выделить стратегию импорта тогда, когда в этом действительно появится необходимость.

### Интерфейс vs. Делегат

Поскольку некоторые стратегии содержат лишь один метод, то очень часто вместо классической стратегии на основе наследования, можно использовать стратегию на основе делегатов. Иногда эти подходы совмещаются, что позволяет использовать наиболее удобный вариант.
 
Классическим примером такой ситуации является "стратегия сортировки", представленная интерфейсами `IComparable<T>` и делегатом `Comparison<T>`:

```csharp
class Employee
{
    publicint Id { get; set; }
    publicstring Name { get; set; }
    public override string ToString()
    {
        returnstring.Format("Id = {0}, Name = {1}", Id, Name);
    }
} 
  
class EmployeeByIdComparer : IComparer<Employee>  
{
    public int Compare(Employee x, Employee y)
    {  
        return x.Id.CompareTo(y.Id);
    }
}
  
public static void SortLists()  
{
    var list = new List<Employee>();
  
    // Используем "функтор"
    list.Sort(new EmployeeByIdComparer());
  
    // Используем делегат  
    list.Sort((x, y) => x.Name.CompareTo(y.Name));  
}```

Реализация интерфейса требует больше кода и приводит к переключению контекста при чтении, по сравнению с использованием лямбда-выражений. В случае с методом `List.Sort` у нас есть оба варианта, но в некоторых случаях классы могут принимать лишь стратегию на основе интерфейса, и не принимать стратегию на основе делегатов, как в случае с классами `SortedList` или `SortedSet`:

```csharp
var comparer = new EmployeeByIdComparer();  
// Конструктор принимает IComparable  
var set = new SortedSet<Employee>(comparer);  
// Нет конструктора, принимающего делегат Comparison<T>```

В этом случае можно сделать сделать небольшой "адаптерный фабричный" класс, который будет принимать делегат `Comparison<T>` и возвращать интерфейс `IComparable<T>`:

```csharp
class ComparerFactory  
{
    publicstaticIComparer<T> Create<T>(Comparison<T> comparer)  
    {
        Contract.Requires(comparer != null);
        return new DelegateComparer<T>(comparer);
    }
    private class DelegateComparer<T> : IComparer<T>
    {
        private readonly Comparison<T> _comparer;

        public DelegateComparer(Comparison<T> comparer)
        {
            _comparer = comparer;
        }

        public int Compare(T x, T y)
        {
            return _comparer(x, y);
        } 
    }
}```

Теперь можно использовать этот фабричный следующим образом:

```csharp
var comparer = ComparerFactory.Create<Employee>(
    (x, y) => x.Id.CompareTo(x.Id));  
var set = new SortedSet<Employee>(comparer);
```

**ПРИМЕЧАНИЕ**  
Аналогично, можно пойти еще дальше, и вместо метода "императивного" подхода на основе делегата `Comparison<T>`, можно получить более "декларативное" решение аналогичное тому, что используется в методе [Enumerable.OrderyBy](http://msdn.microsoft.com/en-us/library/system.linq.enumerable.orderby(v=vs.110).aspx): на основе "селектора" свойств для сравнения.

## Классическое представление паттерна Стратегия

![Рисунок1.2](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%201%20-%20Behavioral%20Patterns/Images/ch01_Image2.png)    
Рисунок 1.2 - Диаграмма классов классического представления паттерна Стратегия

Обратите внимание, что классический паттерн Стратегии весьма абстрактен.

* Паттерн Стратегия не специфицирует интерфейсы контекста (класса `LogProcessor`) и стратегии (интерфейса `ILogReader`).
* Паттерн Стратегия не определяет, как стратегия получит данные, необходимые для выполнения своей работы. Они могут передаваться в аргументах метода стратегии, или стратегия может получать ссылку на сам контекст и получать требуемые данные самостоятельно.
* Паттерн Стратегия не определяет, каким образом контекст получает экземпляр стратегии. Контекст может получать ее в аргументах конструктора, через метод или свойство или получать ее у третьей стороны.

## Применимость

Применимость стратегии полностью определяется ее назначением: паттерн Стратегия нужно использовать для моделирования семейства алгоритмов и операций, когда есть необходимость замены одного поведения другим во время исполнения.

Не следует использовать Стретегию "на всякий случай". Наследование добавляет гибкости, но и приводит к увеличению сложности. Любой класс уже ограничивает своих клиентов от деталей реализации, и позволяет изменять эти детали не затрагивая клиентов. Наличие полиморфизма усложняет чтение кода, а "дырявые абстракции" и нарушения принципа замещения Лисков существенно усложняет поддержку и сопровождение такого кода.

Гибкость не бывает бесплатной, поэтому выделять стратегии стоит тогда, когда  действительно нужна замена поведения во время исполнения.