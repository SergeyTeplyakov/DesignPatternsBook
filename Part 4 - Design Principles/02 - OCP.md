## Глава 3. Принцип открыт/закрыт

**Цитата**: _Отыщи всему начало и ты многое поймешь._
Или: _Где начало того конца, которым оканчивается начало?_
Козьма Прутков

**ЦИТАТА:** _Эффективные проекты контролируют изменения; неэффективные проекты находятся под контролем изменений._
Стив Макконнелл "Остаться в живых" (*)
Сноска: Стив Макконнелл "Остаться в живых! Руководство для менеджера программных проектов", Питер, 2006

**TODO: была мысль использовать в этой части только лишь цитаты Козьмы Пруткова, а в другой части использовать другие цитаты. Можно отойти от этой практики. Вот отличная цитата от Стива Макконнелла:**

**Принцип открыт/закрыт (Open-Closed Principle, OCP)**: _Программные сущности (классы, модули, функции и т.п.) должны быть открытыми для расширения, но закрытыми для модификации._   
Роберт Мартин. "Принципы, паттерны и практики гибкой разработки" [Martin2006]

Чтобы предотвратить загнивание дизайна по мере развития приложения, разработчики и менеджеры должны быть уверенными в том, что изменения являются корректными, а их наличие не повлечет за собой появление ошибок в других частях системы. Простые классы и модули, которые следуют принципу единой обязанности, являются хорошей стартовой точкой для получения адаптивного дизайна, но этого не всегда достаточно.

По мере развития, в системе появляются семейства объектов с общим поведением и схожими интерфейсами. В результате появляются иерархии наследования, в базовых классах которых помещается общее поведение, а наследники его изменяют при необходимости. Помимо повторного использования кода, наследование позволяет легко добавлять новые типы и изменять поведение существующих.

Полученные иерархии типов одновременно являются открытыми и закрытыми. Открытость говорит о простоте добавления новых типов, а закрытость говорит о стабильности интерфейсов базовых классов иерархии.

### Путаница с определениями

Из всех SOLID-принципов, принцип Открыт/Закрыт является самым неоднозначным. Его неоднозначность кроется в противоречивости его определения, а подкрепляется разнообразными описаниями этого принципа в разных источниках. Не удивительно, что даже такие яркие представители нашей отрасли, как [Эрик Липперт](http://ericlippert.com/) (гуру C#) или [Джон Скит](http://codeblog.jonskeet.uk/)  ("Чак Норрис" со StackOverflow.com), относятся к этому принципу неоднозначно и признаются в его непонимании.

Сноска (*): Эрик Липперт является автором известного среди .NET разработчиков блога "Fabulous adventures in coding", а Джон Скит является Top 1 пользователем stackoverflow.com - самого популярного в интернете сайта вопросов/ответов по разработке ПО.

Принцип Открыт-Закрыт был изначально сформулирован Бертраном Мейером в первом издании его книги "Объектно-ориентированное конструирование программных систем" еще в 1988 году (*), но популярность этот принцип завоевал благодаря трудам Роберта Мартина.

Сноска (*): Бертран Мейер является признанным гуру в мире объектно-ориентированного программирования и автором одной из наиболее влиятельных книг по разработке ПО - "Объектно-ориентированное конструирование программных систем", Интернет-Университет, 2005.

**Определение от Боба Мартина**

> Программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для модификации.

> Таким образом у модулей есть две основные характеристики:

> * **Они открыты для расширения**. Это означает, что поведение модуля можно расширить. Когда требования к приложению изменяются, мы добавляем в модуль новое поведение, отвечающее изменившимся требованиям. Иными словами, мы можем изменить состав функций модуля.

> * **Они закрыты для модификации**. Расширение поведения модуля не сопряжено с изменениями в исходном или двоичном коде модуля. Двоичное исполняемое представление модуля, будь то компонуемая библиотека, DLL или EXE-файл, остается неизменным.

Из этого определения может сложится впечатление, что следование принципу Открыт/Закрыт подразумевает использование расширяемых решений на основе подключаемых модулей (pluggable architecture) и обилие наследования. На самом деле, это не так, и даже сам автор этих слов ("дядюшка" Боб Мартин) со временем несколько изменил свое отношение к этому принципу. В своей статье ["An Open and Closed Case"](http://blog.8thlight.com/uncle-bob/2013/03/08/AnOpenAndClosedCase.html) (*) Боб Мартин написал, что со временем он стал мудрее, и менее категоричным в своих высказываниях (на момент описания принципа Открыт-Закрыт в статье 1996-го года ему было "всего" 43).

(*) Сноска: An Open and Closed Case by Uncle Bob - http://blog.8thlight.com/uncle-bob/2013/03/08/AnOpenAndClosedCase.html.

Теперь давайте перейдем к определению от Бертрана Мейера и попробуем понять, что же имел ввиду исходный автор этого принципа.

**Определение от Бертрана Мейера**

> Модули должны иметь возможность быть как открытыми, так и закрытыми.

> При этом понятия открытости и закрытости определяются так:

> * **Модуль называют открытым, если он еще доступен для расширения**. Например, имеется возможность расширить множество операций в нем или добавить поля к его структурам данных.

> * **Модуль называют закрытым, если он доступен для использования другими модулями**. Это означает, что модуль (его интерфейс – с точки зрения скрытия информации) уже имеет строго определенное окончательное описание. На уровне реализации закрытое состояние модуля означает, что модуль можно компилировать, сохранять в библиотеке и делать его доступным для использования другими модулями (его клиентами).

Так что же означает принцип открыт/закрыт?

Исходный посыл Мейера заключается не столько в расширяемости системы, сколько в управляемости процесса разработки: "необходимо, особенно с точки зрения руководителя проекта, закрывать модули. В системе, состоящей из многих модулей, большинство модулей зависимы. Например, модуль интерфейса пользователя может зависеть от модуля синтаксического разбора – синтаксического анализатора и модуля графики. Синтаксический анализатор может зависеть от модуля лексического анализа, и так далее. Если не закрывать модуль до тех пор, пока не будет уверенности, что он уже содержит все необходимые компоненты, то невозможно будет завершить разработку многомодульной программы: каждый из разработчиков будет вынужден ожидать, когда же завершит свою работу все остальные".

Другими словами, Мейер говорит о том, что интерфейс модуля должен быть закрытым, а реализация и точное поведение может варьироваться и оставаться открытым к изменениям.

![Image 1](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch02_Image1.png)
Рисунок 2.1 - Открытость и закрытость классов

Когда нам может понадобиться изменять поведение без изменения интерфейса? Например, когда у существующего класса появляется вторая группа клиентов, которой требуется аналогичное поведение, но с небольшими изменениями. В объектно-ориентированном мире это означает создание наследника, который использует повторно весь код базового класса и переопределяет ряд методов для обеспечения нового поведения.

В результате добавления наследника, интерфейс и поведение нашего исходного класса (класса  `А`) остается неизменным, что гарантирует правильное функционирование его старых клиентов, а новые клиенты используют модифицированную версию класса (класс `А’`).

Данный принцип не говорит, что создание наследника - это единственный возможный или же необходимый способ адаптации существующего кода к новым требованиям. Бертран Мейер является признанным гуру в области объектно-ориентированного программирования, и описывает в своей книге 12 видов наследования, но даже он относится к расширяемости модулей путем создания наследников с разумным прагматизмом: "Если имеется возможность переписать исходную программу так, чтобы она, без излишнего усложнения, смогла удовлетворять потребности нескольких разновидностей клиентов, то следует это сделать".

Естественно, модуль должен модифицироваться при наличии в нем ошибок: "Как принцип Открыт-Закрыт, так и переопределение в механизме наследования не позволяет справиться с дефектами разработки, не говоря уже об ошибках в программе. Если в модуле что-то не в порядке, то следует это сразу исправить в исходной программе, не пытаясь разбираться возникающей проблемой в производном модуле."

(Ради справки, Мейер трактует понятия «модуля» и «класса» одинаковым образом!)

### Принцип единственного выбора
Давайте для закрепления изученного рассмотрим такой пример. Предположим, у нас есть иерархия классов, предназначенных для импортирования данных из файлов разных форматов. Также у нас есть фабричный метод, который создает нужный `Importer` в зависимости от расширения файла:

```csharp
abstract class Importer
{
    public abstract void ImportData();
}

static class ImporterFactory
{
    public static Importer Create(string fileName)
    {
        Contract.Requires(!string.IsNullOrEmpty(fileName));
        Contract.Ensures(Contract.Result<Importer>() != null);

        var extension = Path.GetExtension(fileName);
        switch (extension)
        {
            case "json":
                return new JsonImporter();
            case "xls":
            case "xlsx":
                return new XlsImporter();
            default:
                throw new InvalidOperationException(
                  "Extension is not supported");
        }
    }
}
```

Отвечает ли реализация такой фабрики принципу Открыт/Закрыт? Или для соответствия этому принципу нам нужно вводить интерфейс `IImporterFactory` и еще одну иерархию – иерархию фабрик? А кто будет создавать фабрику? С помощью фабрики фабрик?

Фабричный метод (TODO: дать ссылку на соответствующую главу) является очень распространенным паттерном проектирования, который прячет от своих клиентов способ получения создаваемого экземпляра. Вот что пишет Бертран Мейер по этому поводу: "необходимо допускать возможность того, что список вариантов, заданных и известных на некотором этапе разработки программы, может в последующем быть изменен путем добавления или удаления вариантов. Чтобы обеспечить реализацию такого подхода к процессу разработки программного обеспечения, нужно найти способ защитить структуру программы от воздействия подобных изменений. Отсюда следует принцип Единственного Выбора":

> **Принцип единственного выбора**: всякий раз, когда система программного обеспечения должна поддерживать множество альтернатив, их полный список должен быть известен только одному модулю системы.

Это означает, что с дизайном нашей фабрики все хорошо, до тех пор, пока список вариантов является ее деталью реализации. Если же список типов начнет бродить по коду приложения, то вот тогда нам и понадобится еще один уровень абстракции, который ограничит распространение этой информации минимальным числом классов.

### Какую проблему призван решить принцип Открыт/Закрыт?

**Смысл принципа OCP**: дизайн системы должен быть простым и устойчивым к изменениям.

Это значит, что когда требования изменятся (не «если», а именно «когда»), вы должны быть к этому готовы. Это не означает, что нужно создавать дополнительные уровни абстракции в приложении без необходимости. Мы просто должны ограничить каскад изменений и свести их количество к минимуму.

Как этого добиться?

**Во-первых, за счет абстракции и инкапсуляции**. Выделение существенных (важных) частей системы открытой части класса, позволяет сосредоточиться на важных аспектах поведения, не задумываясь о реализации, скрытой от клиентов в закрытой его части. Важно понимать, что абстракция не требует наличия интерфейсов или абстрактных классов. Класс `String` абстрагирует нас от конкретного представления строки и многих других подробностей, хотя и не реализует интерфейс `IString`.

Сокрытие информации (information hiding) заключается не только в наличии закрытых полей, недоступных клиентам класса/модуля. Сокрытие информации (или даже "сокрытие реализации" - implementation hiding) позволяет думать о классе, как о черном ящике, который представляет определенные услуги лишь ему известным способом [Booch2004]:

> Лисков прямо утверждает, что "абстракция будет работать только вместе с инкапсуляцией". Практически это означает наличие двух частей в классе: интерфейса и реализации. Интерфейс отражает внешнее поведение объекта, описывая абстракцию поведения всех объектов данного класса. Внутренняя реализация описывает представление этой абстракции и механизмы достижения желаемого поведения. Принцип разделения интерфейса и реализации соответствует сути вещей: в интерфейсной части собрано все, что касается взаимодействия данного объекта с любыми другими объектами; реализация скрывает от других объектов все детали, не имеющие отношения к процессу взаимодействия объектов.

**Во-вторых, за счет наследования**. Выделение интерфейсов и абстрактных классов позволяет думать о задаче еще более абстрактно. Полиморфное поведение позволяет заменить один вариант реализации на другой во время исполнения, а также позволит использовать повторно значительные куски кода.

### Принцип открыт/закрыт в реальном мире

Давайте рассмотрим конкретный пример того, как иерархия наследования упрощает решение и делает его при этом более расширяемым. Для этого мы снова вернемся к плагину для упрощения контрактного программирования. С точки зрения библиотеки Code Contracts существует несколько способов проверки предусловий:

* С помощью `Contract.Requires`.
* С помощью `if-throw` с последующим вызовом метода `Contract.EndContractBlock`, или
* С помощью кастомных валидаторов – методов, помеченных атрибутом `CustomArgumentValidator` (*).

(*) СНОСКА: Подробности и тонкостях библиотеки Code Contract можно найти в официальной документации: http://research.microsoft.com/en-us/projects/contracts/userdoc.pdf

Любая проверка предусловия выражается в виде интерфейса `IPrecondition` с методом `ChecksForNotNull`. Существует несколько наследников, каждый из которых отвечает конкретной синтаксической конструкции проверки аргумента.

![Рисунок 2](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch01_Image2.png)
Рисунок 2.2. - Диаграмма классов проверки предусловий

В большинстве случаев, при работе с контрактами не важно, какой вид проверки предусловия используется в коде. Например, если в коде уже есть проверка аргумента на `null` с помощью `if-throw` или любым доступным способом, то контекстное действие по добавлению предусловия должно отсутствовать. Использование `IPrecondition` позволяет думать о задаче более "абстрактно", не отвлекаясь на детали, и более декларативно выражать правила предметной области.

```csharp
private bool IsArgumentAlreadyVerifiedByPrecondition(
    ICSharpFunctionDeclaration functionDeclaration, string parameterName)
{
    return functionDeclaration.GetPreconditions()
        .Any(p => p.ChecksForNotNull(parameterName));
}
```

Сокрытие конкретных типов иерархии наследования позволяет сделать решение открытым и закрытым одновременно. Код является закрытым, поскольку интерфейс `IPrecondition` зафиксирован и мы можем строить свое решение на его основе. Но код также является открытым, поскольку мы всегда можем добавить новый вид предусловия с минимумом усилий.

Минимизация использования конкретных типов иерархии наследования представляет своеобразную форму сокрытия (или ограничения) информации. Чем в меньшем числе мест используются конкретные классы, тем легче изменять иерархию наследования в случае изменения требований. Но не нужно думать, будто "правильная" иерархия может быть написана с первого раза. Любая сложная иерархия строится путем последовательных улучшений. На ранних этапах разработки не всегда ясно, какой поведение можно использовать повторно и какой набор операций является наиболее подходящим. Иерархия обычно несколько раз уточняется и изменяется, прежде чем прийти к устойчивому состоянию, которое будет наиболее полезным.

### Расширяемость: объектно-ориентированный и функциональный подходы
TODO: подумать еще о названии!

При рассмотрении принципа открыт/закрыт очень часто сравнивают подходы структурного и объектно-ориентированного программирования на примере рисования фигур:

```csharp
public static void DrawShape(Shape shape)
{
  switch(shape.ShapeType)
  {
    case ShapeType.Circle:
      DrawCircle((Circle)shape);
      break;
    case ShapeType.Square:
      DrawSquare((Square)shape);
      break;
    case ShapeType.Rectangle:
      DrawRectangle((Rectangle)shape);
      break;
    default:
      throw new InvalidOperationException("Неизвестный тип фигуры");
  }
}
```

Данный код является нерасширяемым, поскольку его придется обновлять каждый раз при добавлении новой фигуры. После чего приводится объектно-ориентированное решение за счет использования наследования и полиморфной использования метода `Draw`:

```csharp
public static void DrawShape(Shape shape)
{
  shape.Draw();
}
```

Теперь мы можем сказать: "Смотрите, как здорово, что мы избавились от конструкции `switch` в функции `Draw` и перенесли всю логику в класс `Shape` и его наследники! Теперь наше решение является расширяемым и соответствует принципу Открыт/Закрыт, поскольку мы легко можем к квадрату и треугольнику добавить еще и ромб с кругом!".

Да, действительно, добавить новый класс в иерархию фигур довольно легко, но что если мы хотим добавить новую операцию, например, метод `GetArea`? Добавление нового абстрактного метода в класс `Shape` является "ломающим" изменением (breaking change), и потребует изменения всех классов наследников. Когда вся иерархия контролируется одним человеком, то это не проблема, но если речь касается библиотеки или широко используемых классов, то быть беде.

Объектно-ориентированное решение на основе полиморфизма позволяет легко расширять функциональность лишь в определенном направлении, но не является "открытым" к любым изменениям.

### "Расширяемость" в объектном мире

Объектно-ориентированный подход подразумевает единство данных и операций, но это не всегда удобно или возможно. Рассматривая даже простой пример с фигурами, можно представить себе разные "контексты" использования классов фигур: могут быть модели с бизнес-логикой, а также объекты, которые будут себя рисовать. В DDD (Domain-Driven Design, Предметно-ориентированное проектирование) существует для этого специальное понятие под названием "ограниченный контекст" (Bounded Context). Одно и то же понятие предметной области может обладать разным поведением, в зависимости от контекста использования, и моделироваться разными классами или иерархиями классов.

По мере усложнения решения, у иерархии типов может появиться несколько ярко выраженных обязанностей, что будет нарушать принципу Единой Обязанности. Одна иерархия классов не может отвечать за моделирование поведения пересечения фигур в игре или CAD-приложении (*) и за их отображение на экране. В результате мы можем прийти к двум параллельным иерархиям: `ShapeModels` и `DrawingShapes`. В этом случае идеальный объектно-ориентированный мир "открытости/закрытости" начнет рушиться, поскольку добавление нового типа фигур будет требовать изменения двух иерархий:

(*) СНОСКА: CAD - Computer-Aided Systems или САПР - системы автоматизированного проектирования, такие как Autodesk.

![Image 2-3](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch02_Image3.png)
Рисунок 2.3 - Две параллельные иерархии для моделирования фигур

Даже без параллельных иерархий наследования может возникнуть необходимость вынести логику из иерархии типов. Возможно этой логики слишком много и она точно не поместится в одну иерархию, или же разработчик иерархии типов просто не знает, в чем эта логика будет заключаться. Классическим примером такой ситуации являются деревья выражений (expression trees), которые поддерживаются напрямую компилятором языка C# и BCL.

В языке C# существует встроенная поддержка выражений со стороны компилятора и BCL. Любое выражение в языка C# представляется базовым классом `Expression`, а конкретные конструкции языка - производными классами, такими как `MethodCallExpression` (вызов метода), `NewExpression` (создание объекта) и другими. Особенность деревьев выражений в том, что они являются вложенными (`BinaryExpression` содержит два выражения, `MethodCallExpression` содержит список `ParameterExpression` и т.д.).

**ПРИМЕЧАНИЕ**
Деревья выражений представляют программный код в виде структуры данных, которую можно проанализировать, преобразовать или передать по сети. Деревья выражений являются фундаментальным строительным блоком любых LINQ-провайдеров (*), поскольку позволяют преобразовывать предикаты в SQL-выражения и выполнять запрос на стороне сервера, а не только на стороне клиента.
Анализ и преобразование выражений интенсивно используется при реализации любого LINQ-провайдера, а также может быть полезна и в других случаях. Я минимум трижды использовал деревья выражений в боевом коде за последние несколько лет. Для визуализации формул - [Визуализация деревьев выражений с помощью TeX](http://sergeyteplyakov.blogspot.com/2011/03/tex.html), для реализации кеширующих декораторов - [Кеширующий декоратор на деревьях выражений](http://sergeyteplyakov.blogspot.com/2012/09/blog-post_24.html) и для динамической конфигурации логики приложения - [Знакомство с Dynamic LINQ](http://sergeyteplyakov.blogspot.com/2010/12/dynamic-linq.html).

(*) Сноска: LINQ - Language Integrated Query или Интегрированный язык запросов является универсальным инструментом для работы с последовательностями в языке C#. Причем последовательности не ограничены лишь коллекциями в памяти, это могут быть бесконечные последовательности, генерируемые с помощью блоков итераторов (Iterator Block), запросы к базе данных или другому хранилищу, или же слаботипизированные источники, например, XML.

### "Функциональный" дизайн
Деревья выражений представляют собой довольно сложные вложенные объекты, поэтому не удивительно, что разработчики не хотят помещать логику непосредственно в них. Но такое желание может возникнуть даже для простых иерархий.

Давайте вернемся к плагину для поддержки контрактного программирования. Современные среды разработки научились показывать предупреждения и ошибки компиляции прямо во время редактирования кода. Теперь вам не нужно нажимать F6, чтобы узнать о пропущенной запятой или опечатке в имени метода: Visual Studio (или ReSharper) покажут их через долю секунды после изменения кода.

Компилятор контрактов (Code Contract Compiler) содержит свои собственные ошибки и предупреждения. Например, контракт должен располагаться в начале метода, тип возвращаемого значения должен быть совместим с типом, указанным в `Contract.Ensure<T>` и т.п. Одной из задач моего плагина является демонстрация ошибок компилятора контрактов во время редактирования кода.

![Code Contract Errors](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch02_Image4.png)
Рисунок 2.4 - Ошибки компилятора Code Contract

Любой процесс валидации состоит из трех основных составляющих: непосредственно самого процесса валидации, его результатов и анализа этих результатов. Для простых случаев мы легко можем смешать все эти три обязанности и поместить их в одни класс: нет смысла создавать несколько классов для проверки ввода имени и мобильного телефона. Для более сложной логики разумно вспомнить о принципе единой обязанности и разделении обязанностей (separation of concerns), и разнести аспекты валидации по разным классам.

Для поддержки этой функциональности необходимо проанализировать каждый контрактный оператор (contract statement) и определить, является ли он корректным, или некорректным с точки зрения библиотеки Code Contracts. При этом уровней «некорректности» несколько: это может быть ошибка или предупреждение компилятора, или же это может быть мое собственное предупреждение (Custom Warning).

В результате, для реализации этой возможности были выделены три составляющие:
* Валидаторы: `ContractStatementValidator`.
* Результаты валидации: легковесная иерархия с базовым типом `ValidationResult`.
* Анализаторы результатов валидации: например, классы, которые покажут контекстное меню (Quick Fix), если возможно автоматическое исправление проблемы.

![Validation Results UML](https://github.com/SergeyTeplyakov/DesignPatternsBook/raw/master/Part%202%20-%20Principles/Images/ch02_Image5.png)
Рисунок 2.5 - Диаграмма классов валидации контрактов

Результаты валидации представляют собой легковесные неизменяемые объекты-значения (Value Objects в терминах DDD). Они содержат лишь логику получения текстового описания ошибки, и код ошибки или предупреждение и не знают. Вся логика по работе с результатами валидации находится вне этой иерархии. Классы валидации (`ContractStatementValidator`) проверяют код на соответствие определенным правилам и создают экземпляр `ValidationResult` в зависимости от типа ошибки. Другие классы принимают результаты валидации и выполняют определенные действия по исправлению ошибок в коде, если такое исправление возможно.

Если посмотреть на иерархию `ValidationResult`, то можно сказать, что **сама иерархия классов является стабильной, а набор операций над ней - нет!**

### Паттерн "Посетитель"

В объектно-ориентированном мире простота добавления новых операций над иерархией типов обеспечивается за счет "двойной диспетчеризации", другими словами, за счет использования паттерна Посетитель (TODO: дать ссылку на главу о посетителях!). Для этого в базовый класс `ValidationResult` добавляется абстрактный метод `Accept`, который принимает `IValidationResultVisitor`, а каждый конкретный класс иерархии просто вызывает метод `Visit`:

```csharp
public interface IValidationResultVisitor
{
    void Visit(NoErrorValidationResult vr);
    void Visit(ContractErrorValidationResult vr);
    void Visit(ContractWarningValidationResult vr);
    void Visit(CustomWarningValidationResult vr);
}

public abstract class ValidationResult
{
    private ICSharpStatement _statement;

    protected ValidationResult(ICSharpStatement statement)
    {
        Contract.Requires(statement != null);
        _statement = statement;
    }

    public abstract void Accept(IValidationResultVisitor visitor);
}

public sealed class ContractErrorValidationResult : ValidationResult
{
    // Другие методы пропущены ...

    public override void Accept(IValidationResultVisitor visitor)
    {
        // Благодаря overload resolution будет вызван
        // IValidationResultVisitor.Visit(ContractErrorValidationResult)
        visitor.Visit(this);
    }
}
```

Теперь мы легко может добавлять анализаторы результатов валидации, в зависимости от наших правил. Так, мы можем сделать контекстное действие (Quick Fix), которое будет переносить предусловия в начало метода. Для этого нужно реализовать посетитель `MovePreconditionVisitor` следующим образом:

```csharp
class MovePreconditionVisitor : IValidationResultVisitor
{
    // True в этом свойстве говорит, что "проблема" с кодом является устранимой
    public bool IsIssueFixable { get; private set; }
    public void Visit(NoErrorValidationResult vr)
    {
        IsIssueFixable = false;
    }

    // Данная проблема устранима, если до оператора Contract.Requres
    // находится любой метод: возвращающий результат (Non-void)
    // или нет (non-void метод).

    public void Visit(ContractErrorValidationResult vr)
    {
        IsIssueFixable =
          vr.Error == MalformedContractError.VoidReturnMethodCall;
    }

    public void Visit(ContractWarningValidationResult vr)
    {
        IsIssueFixable =
          vr.Warning == MalformedContractWarning.NonVoidReturnMethodCall;
    }

    public void Visit(CustomWarningValidationResult vr)
    {
        IsIssueFixable = false;
    }
}
```

Теперь мы можем использовать данный посетитель в классе `ContractBlockAnalyzer`, чтобы определить, возможно ли данное конкретное автоматическое исправление кода или нет. Так, свойство `IsIssueFixable` представленного выше посетителя будет возвращать `true`, если внутри контрактного блока находится вызов метода (компилятор контрактов выдает ошибку при использовании внутри блока контрактов void-методов, но выдает предупреждение при вызове метода с возвращающим значением!).

Подход на основе посетителей широко используется на практике, но во многих случаях он является слишком сложным и тяжеловесным. Сложность его обусловлена тем, что классы-посетители решают две проблемы: во-первых, они реализуют двойную диспетчеризацию, а во-вторых, содержат некоторую бизнес-логику.

### Размеченные объединения и сопоставление с образцом

Когда количество конкретных типов иерархии наследования невелико, интерфейс `IValidationResultVisitor` можно заменить списком делегатов. Для этого, метод `Accept` мы переименуем в `Match`, который будет принимать несколько делегатов для обработки конкретных типов иерархии `ValidationResult`:

```csharp
public T Match<T>(
    Func<CodeContractErrorValidationResult, T> errorMatch,
    Func<CodeContractWarningValidationResult, T> warningMatch,
    Func<ValidationResult, T> defaultMatch)
{
    var errorResult = this as CodeContractErrorValidationResult;
    if (errorResult != null)
        return errorMatch(errorResult);

    var warningResult = this as CodeContractWarningValidationResult;
    if (warningResult != null)
        return warningMatch(warningResult);

    return defaultMatch(this);
}
```

Теперь, вместо создания специализированного класса посетителя для каждого случая, можно просто использовать метод `Match` прямо в коде анализатора:

```csharp
// Внутри класса MovePreconditionAnalyzer
ValidationResult vr = GetValidationResult();
bool isFixable = vr.Match(
    error => error.Error ==
        MalformedContractError.VoidReturnMethodCall,
    warning => warning.Warning ==
        MalformedContractWarning.NonVoidReturnMethodCall,
    @default => false);
```

Данный вид посетителя напоминает стандартную технику функционального программирования (ФП) под названием **сопоставление с образцом** (*) (pattern matching). Выбор между функциональной и объектно-ориентированной версией паттерна Посетитель такой же, как и выбор между функциональной и объектно-ориентированной Стратегией. В некоторых случаях удобнее создавать именованный класс, реализующий сложную стратегию сохранения или шифрования данных, но когда речь заходит о сравнении или сортировки объектов, то стратегия на основе лямбда-выражений будет  более предпочтительной. В данном случае компромисс аналогичен: для сложной логики полезно выделить отдельный класс посетителя и спрятать эту логику внутри именованного класса; когда же логики мало, то вариант с лямбда-выражениями выглядит проще и понятнее, поскольку читателю не нужно переключать «контекст» на реализацию посетителя.

(*) СНОСКА: Сопоставление с образцом является очень мощной конструкций функциональных языков программирования и позволяет "сопоставлять" не только типы, а но и диапазоны значений, а также "деконструировать" кортежи и записи (Records). В общем случае сопоставление с образцом можно рассматривать как оператор switch на стероидах. На данный момент язык C# не поддерживает сопоставление с образцом из коробки. Поэтому разработчику приходится дублировать код или же использовать довольно изощренные решения, наподобие того, что описал Барт де Смет (Bart de Smet) в статье ["Pattern Matching in C# - Part 0"](http://community.bartdesmet.net/blogs/bart/archive/2008/04/06/pattern-matching-in-c-part-0.aspx). Разработчики языка C# рассматривают возможность добавления полноценного сопоставления с образцом в одной из следующих версий языка.

В случае использования самописного сопоставления с образцом, мы можем добавить несколько перегруженных методов `Match`, которые будут принимать не все возможные типы иерархии, а лишь некоторые наиболее часто используемые. При этом метод `Match` может находится в базовом классе иерархии наследования, а может быть реализован в виде метода расширения в классе `ValidationResultEx`.

Большинство функциональных языков программирования поддерживают возможность "разбора вариантов" прямо из коробки, а также поддерживают возможность создания "вариантов" более удобным способом.

Так, если взять F#, то весь код иерархии `ValidationResult` будет выглядеть так:

```fsharp
// Перечень ошибок компилятора Code Contract
type MalformedContractError =
    | VoidReturnMethodCall
    | Assignment
    | ContractWithinTryBlock

// Перечень предупреждений компилятора Code Contract
type MalformedContractWarning =
    | NonVoidReturnMethodCall

// Создаем «иерархию» типов ValidationResult
type ValidationResult =
    | NoError
    | ContractError of Error: MalformedContractError
    | ContractWarning of Warning: MalformedContractWarning
    | CustomWarning
```

При этом никакие методы `Match` не понадобятся, поскольку F#, как и любой другой функциональный язык позволяет "деконструировать" экземпляры и приводить их к нужному типу самостоятельно:

```fsharp
let vr = GetValidationResult()
let isFixable =
    match vr with
    | ContractError(Error = er) -> er = MalformedContractError.VoidReturnMethodCall
    | ContractWarning(Warning = wr) -> wr = MalformedContractWarning.NonVoidReturnMethodCall
    | _ -> false
```

***ПРИМЕЧАНИЕ***
Пример с размеченными объединениями показывает еще один способ получения новых типов на основе существующих. Обычный класс или кортеж (tuple) создает новый тип путем объединение внутренних членов по "И": класс `Point` содержит `X` **И** `Y`, класс `Person` – `Id` **И** `Name`, `Tuple<int, string>` - неименованные поля типа `int` И `string`. Размеченное объединение создает новый тип путем объединения членов по "ИЛИ": результат валидации – это `Ok`, `Error` **ИЛИ** `Warning`; в результате анализа данных мы получим `int` **ИЛИ** `string` и т.п.
В объектно-ориентированном мире для объединения членов по **ИЛИ** используем наследование, а в функциональном мире – размеченные объединения (discriminated unions или tagged union).

### Типичные примеры нарушения принципа Открыт-Закрыт

* **Интерфейс класса является нестабильным**. Постоянные изменения интерфейса класса, используемого во множестве мест приводит к постоянным изменениям во многих частях системы.
* **Размазывание информации об иерархии типов**. В коде постоянно используются понижающие приведения типов (downcasting), что "размазывает" информацию об иерархии типов по коду приложения. Это затрудняет добавление новых типов и усложняет понимание текущего решения.

### Заключение

**Что такое OCP?** Фиксация интерфейса класса/модуля, и возможность изменения реализации/поведения.

**Цели OCP**: борьба со сложностью и ограничение изменений минимальным числом модулей.

**Как мы реализуем OCP?** С помощью инкапсуляции, которая позволяет изменять реализацию без изменения интерфейса и с помощью наследования, что позволяет заменить реализацию, которая не затронет существующих клиентов базового класса.

Приведенные выше примеры показывают "ортогональность" объектного и функционального подходов. Классический объектный подход позволяет легко добавлять новые типвы в существующую иерархию типов, а функциональный подход позволяет легко добавлять новые операции. Проблема «однобокости» каждого из решений является одной из классических проблем нашего мира и носит название "Expression Problem" (*).

(*)СНОСКА: одно из лучших описаний данной проблемы можно найти по следующей ссылке: http://c2.com/cgi/wiki?ExpressionProblem

Во время дизайна модуля нужно подумать о том, в каком направлении упрощать расширяемость. Если более вероятным является добавление новых типов, то более подходящим будет классический объектный подход на основе наследования. Если более вероятным является добавление новых операций в существующую иерархию типов, то более подходящим будет функциональный подход на основе размеченных объединений или объектный подход на основе паттерна "Посетитель".
